
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client"
import type * as Prisma from "../models"
import { type PrismaClient } from "./class"

export type * from '../models'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql



/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: 7.4.0
 * Query Engine version: ab56fe763f921d033a6c195e7ddeb3e255bdbb57
 */
export const prismaVersion: PrismaVersion = {
  client: "7.4.0",
  engine: "ab56fe763f921d033a6c195e7ddeb3e255bdbb57"
}

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes
export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue


export const NullTypes = {
  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),
  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),
  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.DbNull

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.JsonNull

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.AnyNull


type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


export const ModelName = {
  User: 'User',
  UserProfile: 'UserProfile',
  Session: 'Session',
  RefreshToken: 'RefreshToken',
  Permission: 'Permission',
  PermissionGroup: 'PermissionGroup',
  PermissionGroupPermission: 'PermissionGroupPermission',
  UserPermissionGroup: 'UserPermissionGroup',
  UserDirectPermission: 'UserDirectPermission',
  PermissionAuditLog: 'PermissionAuditLog',
  Organization: 'Organization',
  OrganizationAddress: 'OrganizationAddress',
  OrganizationCnae: 'OrganizationCnae',
  OrganizationFiscalSettings: 'OrganizationFiscalSettings',
  OrganizationStakeholder: 'OrganizationStakeholder',
  Supplier: 'Supplier',
  Manufacturer: 'Manufacturer',
  Category: 'Category',
  Warehouse: 'Warehouse',
  Zone: 'Zone',
  Bin: 'Bin',
  Volume: 'Volume',
  VolumeItem: 'VolumeItem',
  Template: 'Template',
  Product: 'Product',
  Variant: 'Variant',
  Item: 'Item',
  ItemMovement: 'ItemMovement',
  ProductCategory: 'ProductCategory',
  VariantPriceHistory: 'VariantPriceHistory',
  AuditLog: 'AuditLog',
  Tag: 'Tag',
  ProductTag: 'ProductTag',
  VariantImage: 'VariantImage',
  Alert: 'Alert',
  PurchaseOrder: 'PurchaseOrder',
  PurchaseOrderItem: 'PurchaseOrderItem',
  UnitConversion: 'UnitConversion',
  StockSnapshot: 'StockSnapshot',
  Customer: 'Customer',
  SalesOrder: 'SalesOrder',
  SalesOrderItem: 'SalesOrderItem',
  ItemReservation: 'ItemReservation',
  VariantSupplierCode: 'VariantSupplierCode',
  VariantPromotion: 'VariantPromotion',
  Comment: 'Comment',
  NotificationPreference: 'NotificationPreference',
  NotificationTemplate: 'NotificationTemplate',
  Notification: 'Notification',
  Request: 'Request',
  RequestAttachment: 'RequestAttachment',
  RequestComment: 'RequestComment',
  RequestHistory: 'RequestHistory',
  Employee: 'Employee',
  Department: 'Department',
  Position: 'Position',
  TimeEntry: 'TimeEntry',
  WorkSchedule: 'WorkSchedule',
  Overtime: 'Overtime',
  TimeBank: 'TimeBank',
  Absence: 'Absence',
  VacationPeriod: 'VacationPeriod',
  Payroll: 'Payroll',
  PayrollItem: 'PayrollItem',
  Bonus: 'Bonus',
  Deduction: 'Deduction',
  Company: 'Company',
  CompanyAddress: 'CompanyAddress',
  CompanyCnae: 'CompanyCnae',
  CompanyFiscalSettings: 'CompanyFiscalSettings',
  CompanyStakeholder: 'CompanyStakeholder',
  LabelTemplate: 'LabelTemplate',
  Tenant: 'Tenant',
  Plan: 'Plan',
  PlanModule: 'PlanModule',
  TenantPlan: 'TenantPlan',
  TenantUser: 'TenantUser',
  TenantFeatureFlag: 'TenantFeatureFlag',
  CostCenter: 'CostCenter',
  BankAccount: 'BankAccount',
  FinanceCategory: 'FinanceCategory',
  FinanceEntry: 'FinanceEntry',
  FinanceEntryPayment: 'FinanceEntryPayment',
  FinanceAttachment: 'FinanceAttachment',
  Loan: 'Loan',
  LoanInstallment: 'LoanInstallment',
  Consortium: 'Consortium',
  ConsortiumPayment: 'ConsortiumPayment'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]



export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions
  }
  meta: {
    modelProps: "user" | "userProfile" | "session" | "refreshToken" | "permission" | "permissionGroup" | "permissionGroupPermission" | "userPermissionGroup" | "userDirectPermission" | "permissionAuditLog" | "organization" | "organizationAddress" | "organizationCnae" | "organizationFiscalSettings" | "organizationStakeholder" | "supplier" | "manufacturer" | "category" | "warehouse" | "zone" | "bin" | "volume" | "volumeItem" | "template" | "product" | "variant" | "item" | "itemMovement" | "productCategory" | "variantPriceHistory" | "auditLog" | "tag" | "productTag" | "variantImage" | "alert" | "purchaseOrder" | "purchaseOrderItem" | "unitConversion" | "stockSnapshot" | "customer" | "salesOrder" | "salesOrderItem" | "itemReservation" | "variantSupplierCode" | "variantPromotion" | "comment" | "notificationPreference" | "notificationTemplate" | "notification" | "request" | "requestAttachment" | "requestComment" | "requestHistory" | "employee" | "department" | "position" | "timeEntry" | "workSchedule" | "overtime" | "timeBank" | "absence" | "vacationPeriod" | "payroll" | "payrollItem" | "bonus" | "deduction" | "company" | "companyAddress" | "companyCnae" | "companyFiscalSettings" | "companyStakeholder" | "labelTemplate" | "tenant" | "plan" | "planModule" | "tenantPlan" | "tenantUser" | "tenantFeatureFlag" | "costCenter" | "bankAccount" | "financeCategory" | "financeEntry" | "financeEntryPayment" | "financeAttachment" | "loan" | "loanInstallment" | "consortium" | "consortiumPayment"
    txIsolationLevel: TransactionIsolationLevel
  }
  model: {
    User: {
      payload: Prisma.$UserPayload<ExtArgs>
      fields: Prisma.UserFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findFirst: {
          args: Prisma.UserFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findMany: {
          args: Prisma.UserFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        create: {
          args: Prisma.UserCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        createMany: {
          args: Prisma.UserCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        delete: {
          args: Prisma.UserDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        update: {
          args: Prisma.UserUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        deleteMany: {
          args: Prisma.UserDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        upsert: {
          args: Prisma.UserUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        aggregate: {
          args: Prisma.UserAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUser>
        }
        groupBy: {
          args: Prisma.UserGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType> | number
        }
      }
    }
    UserProfile: {
      payload: Prisma.$UserProfilePayload<ExtArgs>
      fields: Prisma.UserProfileFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserProfileFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserProfileFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload>
        }
        findFirst: {
          args: Prisma.UserProfileFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserProfileFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload>
        }
        findMany: {
          args: Prisma.UserProfileFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
        }
        create: {
          args: Prisma.UserProfileCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload>
        }
        createMany: {
          args: Prisma.UserProfileCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserProfileCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
        }
        delete: {
          args: Prisma.UserProfileDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload>
        }
        update: {
          args: Prisma.UserProfileUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload>
        }
        deleteMany: {
          args: Prisma.UserProfileDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserProfileUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserProfileUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
        }
        upsert: {
          args: Prisma.UserProfileUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload>
        }
        aggregate: {
          args: Prisma.UserProfileAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserProfile>
        }
        groupBy: {
          args: Prisma.UserProfileGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserProfileGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserProfileCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserProfileCountAggregateOutputType> | number
        }
      }
    }
    Session: {
      payload: Prisma.$SessionPayload<ExtArgs>
      fields: Prisma.SessionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SessionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        findFirst: {
          args: Prisma.SessionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        findMany: {
          args: Prisma.SessionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[]
        }
        create: {
          args: Prisma.SessionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        createMany: {
          args: Prisma.SessionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[]
        }
        delete: {
          args: Prisma.SessionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        update: {
          args: Prisma.SessionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        deleteMany: {
          args: Prisma.SessionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SessionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[]
        }
        upsert: {
          args: Prisma.SessionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        aggregate: {
          args: Prisma.SessionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSession>
        }
        groupBy: {
          args: Prisma.SessionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SessionGroupByOutputType>[]
        }
        count: {
          args: Prisma.SessionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SessionCountAggregateOutputType> | number
        }
      }
    }
    RefreshToken: {
      payload: Prisma.$RefreshTokenPayload<ExtArgs>
      fields: Prisma.RefreshTokenFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
        }
        findFirst: {
          args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
        }
        findMany: {
          args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
        }
        create: {
          args: Prisma.RefreshTokenCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
        }
        createMany: {
          args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
        }
        delete: {
          args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
        }
        update: {
          args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
        }
        deleteMany: {
          args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RefreshTokenUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
        }
        upsert: {
          args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
        }
        aggregate: {
          args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRefreshToken>
        }
        groupBy: {
          args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RefreshTokenGroupByOutputType>[]
        }
        count: {
          args: Prisma.RefreshTokenCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RefreshTokenCountAggregateOutputType> | number
        }
      }
    }
    Permission: {
      payload: Prisma.$PermissionPayload<ExtArgs>
      fields: Prisma.PermissionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PermissionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>
        }
        findFirst: {
          args: Prisma.PermissionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>
        }
        findMany: {
          args: Prisma.PermissionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>[]
        }
        create: {
          args: Prisma.PermissionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>
        }
        createMany: {
          args: Prisma.PermissionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PermissionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>[]
        }
        delete: {
          args: Prisma.PermissionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>
        }
        update: {
          args: Prisma.PermissionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>
        }
        deleteMany: {
          args: Prisma.PermissionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PermissionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PermissionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>[]
        }
        upsert: {
          args: Prisma.PermissionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>
        }
        aggregate: {
          args: Prisma.PermissionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePermission>
        }
        groupBy: {
          args: Prisma.PermissionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PermissionGroupByOutputType>[]
        }
        count: {
          args: Prisma.PermissionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PermissionCountAggregateOutputType> | number
        }
      }
    }
    PermissionGroup: {
      payload: Prisma.$PermissionGroupPayload<ExtArgs>
      fields: Prisma.PermissionGroupFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PermissionGroupFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionGroupPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PermissionGroupFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionGroupPayload>
        }
        findFirst: {
          args: Prisma.PermissionGroupFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionGroupPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PermissionGroupFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionGroupPayload>
        }
        findMany: {
          args: Prisma.PermissionGroupFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionGroupPayload>[]
        }
        create: {
          args: Prisma.PermissionGroupCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionGroupPayload>
        }
        createMany: {
          args: Prisma.PermissionGroupCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PermissionGroupCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionGroupPayload>[]
        }
        delete: {
          args: Prisma.PermissionGroupDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionGroupPayload>
        }
        update: {
          args: Prisma.PermissionGroupUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionGroupPayload>
        }
        deleteMany: {
          args: Prisma.PermissionGroupDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PermissionGroupUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PermissionGroupUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionGroupPayload>[]
        }
        upsert: {
          args: Prisma.PermissionGroupUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionGroupPayload>
        }
        aggregate: {
          args: Prisma.PermissionGroupAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePermissionGroup>
        }
        groupBy: {
          args: Prisma.PermissionGroupGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PermissionGroupGroupByOutputType>[]
        }
        count: {
          args: Prisma.PermissionGroupCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PermissionGroupCountAggregateOutputType> | number
        }
      }
    }
    PermissionGroupPermission: {
      payload: Prisma.$PermissionGroupPermissionPayload<ExtArgs>
      fields: Prisma.PermissionGroupPermissionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PermissionGroupPermissionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionGroupPermissionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PermissionGroupPermissionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionGroupPermissionPayload>
        }
        findFirst: {
          args: Prisma.PermissionGroupPermissionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionGroupPermissionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PermissionGroupPermissionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionGroupPermissionPayload>
        }
        findMany: {
          args: Prisma.PermissionGroupPermissionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionGroupPermissionPayload>[]
        }
        create: {
          args: Prisma.PermissionGroupPermissionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionGroupPermissionPayload>
        }
        createMany: {
          args: Prisma.PermissionGroupPermissionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PermissionGroupPermissionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionGroupPermissionPayload>[]
        }
        delete: {
          args: Prisma.PermissionGroupPermissionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionGroupPermissionPayload>
        }
        update: {
          args: Prisma.PermissionGroupPermissionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionGroupPermissionPayload>
        }
        deleteMany: {
          args: Prisma.PermissionGroupPermissionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PermissionGroupPermissionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PermissionGroupPermissionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionGroupPermissionPayload>[]
        }
        upsert: {
          args: Prisma.PermissionGroupPermissionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionGroupPermissionPayload>
        }
        aggregate: {
          args: Prisma.PermissionGroupPermissionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePermissionGroupPermission>
        }
        groupBy: {
          args: Prisma.PermissionGroupPermissionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PermissionGroupPermissionGroupByOutputType>[]
        }
        count: {
          args: Prisma.PermissionGroupPermissionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PermissionGroupPermissionCountAggregateOutputType> | number
        }
      }
    }
    UserPermissionGroup: {
      payload: Prisma.$UserPermissionGroupPayload<ExtArgs>
      fields: Prisma.UserPermissionGroupFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserPermissionGroupFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPermissionGroupPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserPermissionGroupFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPermissionGroupPayload>
        }
        findFirst: {
          args: Prisma.UserPermissionGroupFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPermissionGroupPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserPermissionGroupFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPermissionGroupPayload>
        }
        findMany: {
          args: Prisma.UserPermissionGroupFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPermissionGroupPayload>[]
        }
        create: {
          args: Prisma.UserPermissionGroupCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPermissionGroupPayload>
        }
        createMany: {
          args: Prisma.UserPermissionGroupCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserPermissionGroupCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPermissionGroupPayload>[]
        }
        delete: {
          args: Prisma.UserPermissionGroupDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPermissionGroupPayload>
        }
        update: {
          args: Prisma.UserPermissionGroupUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPermissionGroupPayload>
        }
        deleteMany: {
          args: Prisma.UserPermissionGroupDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserPermissionGroupUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserPermissionGroupUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPermissionGroupPayload>[]
        }
        upsert: {
          args: Prisma.UserPermissionGroupUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPermissionGroupPayload>
        }
        aggregate: {
          args: Prisma.UserPermissionGroupAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserPermissionGroup>
        }
        groupBy: {
          args: Prisma.UserPermissionGroupGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserPermissionGroupGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserPermissionGroupCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserPermissionGroupCountAggregateOutputType> | number
        }
      }
    }
    UserDirectPermission: {
      payload: Prisma.$UserDirectPermissionPayload<ExtArgs>
      fields: Prisma.UserDirectPermissionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserDirectPermissionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDirectPermissionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserDirectPermissionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDirectPermissionPayload>
        }
        findFirst: {
          args: Prisma.UserDirectPermissionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDirectPermissionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserDirectPermissionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDirectPermissionPayload>
        }
        findMany: {
          args: Prisma.UserDirectPermissionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDirectPermissionPayload>[]
        }
        create: {
          args: Prisma.UserDirectPermissionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDirectPermissionPayload>
        }
        createMany: {
          args: Prisma.UserDirectPermissionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserDirectPermissionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDirectPermissionPayload>[]
        }
        delete: {
          args: Prisma.UserDirectPermissionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDirectPermissionPayload>
        }
        update: {
          args: Prisma.UserDirectPermissionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDirectPermissionPayload>
        }
        deleteMany: {
          args: Prisma.UserDirectPermissionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserDirectPermissionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserDirectPermissionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDirectPermissionPayload>[]
        }
        upsert: {
          args: Prisma.UserDirectPermissionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDirectPermissionPayload>
        }
        aggregate: {
          args: Prisma.UserDirectPermissionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserDirectPermission>
        }
        groupBy: {
          args: Prisma.UserDirectPermissionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserDirectPermissionGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserDirectPermissionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserDirectPermissionCountAggregateOutputType> | number
        }
      }
    }
    PermissionAuditLog: {
      payload: Prisma.$PermissionAuditLogPayload<ExtArgs>
      fields: Prisma.PermissionAuditLogFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PermissionAuditLogFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionAuditLogPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PermissionAuditLogFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionAuditLogPayload>
        }
        findFirst: {
          args: Prisma.PermissionAuditLogFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionAuditLogPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PermissionAuditLogFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionAuditLogPayload>
        }
        findMany: {
          args: Prisma.PermissionAuditLogFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionAuditLogPayload>[]
        }
        create: {
          args: Prisma.PermissionAuditLogCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionAuditLogPayload>
        }
        createMany: {
          args: Prisma.PermissionAuditLogCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PermissionAuditLogCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionAuditLogPayload>[]
        }
        delete: {
          args: Prisma.PermissionAuditLogDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionAuditLogPayload>
        }
        update: {
          args: Prisma.PermissionAuditLogUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionAuditLogPayload>
        }
        deleteMany: {
          args: Prisma.PermissionAuditLogDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PermissionAuditLogUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PermissionAuditLogUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionAuditLogPayload>[]
        }
        upsert: {
          args: Prisma.PermissionAuditLogUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionAuditLogPayload>
        }
        aggregate: {
          args: Prisma.PermissionAuditLogAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePermissionAuditLog>
        }
        groupBy: {
          args: Prisma.PermissionAuditLogGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PermissionAuditLogGroupByOutputType>[]
        }
        count: {
          args: Prisma.PermissionAuditLogCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PermissionAuditLogCountAggregateOutputType> | number
        }
      }
    }
    Organization: {
      payload: Prisma.$OrganizationPayload<ExtArgs>
      fields: Prisma.OrganizationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>
        }
        findFirst: {
          args: Prisma.OrganizationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>
        }
        findMany: {
          args: Prisma.OrganizationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
        }
        create: {
          args: Prisma.OrganizationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>
        }
        createMany: {
          args: Prisma.OrganizationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
        }
        delete: {
          args: Prisma.OrganizationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>
        }
        update: {
          args: Prisma.OrganizationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>
        }
        deleteMany: {
          args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OrganizationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
        }
        upsert: {
          args: Prisma.OrganizationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>
        }
        aggregate: {
          args: Prisma.OrganizationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOrganization>
        }
        groupBy: {
          args: Prisma.OrganizationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrganizationGroupByOutputType>[]
        }
        count: {
          args: Prisma.OrganizationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrganizationCountAggregateOutputType> | number
        }
      }
    }
    OrganizationAddress: {
      payload: Prisma.$OrganizationAddressPayload<ExtArgs>
      fields: Prisma.OrganizationAddressFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OrganizationAddressFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationAddressPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OrganizationAddressFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationAddressPayload>
        }
        findFirst: {
          args: Prisma.OrganizationAddressFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationAddressPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OrganizationAddressFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationAddressPayload>
        }
        findMany: {
          args: Prisma.OrganizationAddressFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationAddressPayload>[]
        }
        create: {
          args: Prisma.OrganizationAddressCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationAddressPayload>
        }
        createMany: {
          args: Prisma.OrganizationAddressCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OrganizationAddressCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationAddressPayload>[]
        }
        delete: {
          args: Prisma.OrganizationAddressDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationAddressPayload>
        }
        update: {
          args: Prisma.OrganizationAddressUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationAddressPayload>
        }
        deleteMany: {
          args: Prisma.OrganizationAddressDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OrganizationAddressUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OrganizationAddressUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationAddressPayload>[]
        }
        upsert: {
          args: Prisma.OrganizationAddressUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationAddressPayload>
        }
        aggregate: {
          args: Prisma.OrganizationAddressAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOrganizationAddress>
        }
        groupBy: {
          args: Prisma.OrganizationAddressGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrganizationAddressGroupByOutputType>[]
        }
        count: {
          args: Prisma.OrganizationAddressCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrganizationAddressCountAggregateOutputType> | number
        }
      }
    }
    OrganizationCnae: {
      payload: Prisma.$OrganizationCnaePayload<ExtArgs>
      fields: Prisma.OrganizationCnaeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OrganizationCnaeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationCnaePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OrganizationCnaeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationCnaePayload>
        }
        findFirst: {
          args: Prisma.OrganizationCnaeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationCnaePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OrganizationCnaeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationCnaePayload>
        }
        findMany: {
          args: Prisma.OrganizationCnaeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationCnaePayload>[]
        }
        create: {
          args: Prisma.OrganizationCnaeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationCnaePayload>
        }
        createMany: {
          args: Prisma.OrganizationCnaeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OrganizationCnaeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationCnaePayload>[]
        }
        delete: {
          args: Prisma.OrganizationCnaeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationCnaePayload>
        }
        update: {
          args: Prisma.OrganizationCnaeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationCnaePayload>
        }
        deleteMany: {
          args: Prisma.OrganizationCnaeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OrganizationCnaeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OrganizationCnaeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationCnaePayload>[]
        }
        upsert: {
          args: Prisma.OrganizationCnaeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationCnaePayload>
        }
        aggregate: {
          args: Prisma.OrganizationCnaeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOrganizationCnae>
        }
        groupBy: {
          args: Prisma.OrganizationCnaeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrganizationCnaeGroupByOutputType>[]
        }
        count: {
          args: Prisma.OrganizationCnaeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrganizationCnaeCountAggregateOutputType> | number
        }
      }
    }
    OrganizationFiscalSettings: {
      payload: Prisma.$OrganizationFiscalSettingsPayload<ExtArgs>
      fields: Prisma.OrganizationFiscalSettingsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OrganizationFiscalSettingsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationFiscalSettingsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OrganizationFiscalSettingsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationFiscalSettingsPayload>
        }
        findFirst: {
          args: Prisma.OrganizationFiscalSettingsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationFiscalSettingsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OrganizationFiscalSettingsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationFiscalSettingsPayload>
        }
        findMany: {
          args: Prisma.OrganizationFiscalSettingsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationFiscalSettingsPayload>[]
        }
        create: {
          args: Prisma.OrganizationFiscalSettingsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationFiscalSettingsPayload>
        }
        createMany: {
          args: Prisma.OrganizationFiscalSettingsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OrganizationFiscalSettingsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationFiscalSettingsPayload>[]
        }
        delete: {
          args: Prisma.OrganizationFiscalSettingsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationFiscalSettingsPayload>
        }
        update: {
          args: Prisma.OrganizationFiscalSettingsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationFiscalSettingsPayload>
        }
        deleteMany: {
          args: Prisma.OrganizationFiscalSettingsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OrganizationFiscalSettingsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OrganizationFiscalSettingsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationFiscalSettingsPayload>[]
        }
        upsert: {
          args: Prisma.OrganizationFiscalSettingsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationFiscalSettingsPayload>
        }
        aggregate: {
          args: Prisma.OrganizationFiscalSettingsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOrganizationFiscalSettings>
        }
        groupBy: {
          args: Prisma.OrganizationFiscalSettingsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrganizationFiscalSettingsGroupByOutputType>[]
        }
        count: {
          args: Prisma.OrganizationFiscalSettingsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrganizationFiscalSettingsCountAggregateOutputType> | number
        }
      }
    }
    OrganizationStakeholder: {
      payload: Prisma.$OrganizationStakeholderPayload<ExtArgs>
      fields: Prisma.OrganizationStakeholderFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OrganizationStakeholderFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationStakeholderPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OrganizationStakeholderFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationStakeholderPayload>
        }
        findFirst: {
          args: Prisma.OrganizationStakeholderFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationStakeholderPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OrganizationStakeholderFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationStakeholderPayload>
        }
        findMany: {
          args: Prisma.OrganizationStakeholderFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationStakeholderPayload>[]
        }
        create: {
          args: Prisma.OrganizationStakeholderCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationStakeholderPayload>
        }
        createMany: {
          args: Prisma.OrganizationStakeholderCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OrganizationStakeholderCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationStakeholderPayload>[]
        }
        delete: {
          args: Prisma.OrganizationStakeholderDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationStakeholderPayload>
        }
        update: {
          args: Prisma.OrganizationStakeholderUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationStakeholderPayload>
        }
        deleteMany: {
          args: Prisma.OrganizationStakeholderDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OrganizationStakeholderUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OrganizationStakeholderUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationStakeholderPayload>[]
        }
        upsert: {
          args: Prisma.OrganizationStakeholderUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationStakeholderPayload>
        }
        aggregate: {
          args: Prisma.OrganizationStakeholderAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOrganizationStakeholder>
        }
        groupBy: {
          args: Prisma.OrganizationStakeholderGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrganizationStakeholderGroupByOutputType>[]
        }
        count: {
          args: Prisma.OrganizationStakeholderCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrganizationStakeholderCountAggregateOutputType> | number
        }
      }
    }
    Supplier: {
      payload: Prisma.$SupplierPayload<ExtArgs>
      fields: Prisma.SupplierFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SupplierFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SupplierFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPayload>
        }
        findFirst: {
          args: Prisma.SupplierFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SupplierFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPayload>
        }
        findMany: {
          args: Prisma.SupplierFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPayload>[]
        }
        create: {
          args: Prisma.SupplierCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPayload>
        }
        createMany: {
          args: Prisma.SupplierCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SupplierCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPayload>[]
        }
        delete: {
          args: Prisma.SupplierDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPayload>
        }
        update: {
          args: Prisma.SupplierUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPayload>
        }
        deleteMany: {
          args: Prisma.SupplierDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SupplierUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SupplierUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPayload>[]
        }
        upsert: {
          args: Prisma.SupplierUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPayload>
        }
        aggregate: {
          args: Prisma.SupplierAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSupplier>
        }
        groupBy: {
          args: Prisma.SupplierGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SupplierGroupByOutputType>[]
        }
        count: {
          args: Prisma.SupplierCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SupplierCountAggregateOutputType> | number
        }
      }
    }
    Manufacturer: {
      payload: Prisma.$ManufacturerPayload<ExtArgs>
      fields: Prisma.ManufacturerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ManufacturerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ManufacturerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ManufacturerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ManufacturerPayload>
        }
        findFirst: {
          args: Prisma.ManufacturerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ManufacturerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ManufacturerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ManufacturerPayload>
        }
        findMany: {
          args: Prisma.ManufacturerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ManufacturerPayload>[]
        }
        create: {
          args: Prisma.ManufacturerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ManufacturerPayload>
        }
        createMany: {
          args: Prisma.ManufacturerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ManufacturerCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ManufacturerPayload>[]
        }
        delete: {
          args: Prisma.ManufacturerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ManufacturerPayload>
        }
        update: {
          args: Prisma.ManufacturerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ManufacturerPayload>
        }
        deleteMany: {
          args: Prisma.ManufacturerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ManufacturerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ManufacturerUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ManufacturerPayload>[]
        }
        upsert: {
          args: Prisma.ManufacturerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ManufacturerPayload>
        }
        aggregate: {
          args: Prisma.ManufacturerAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateManufacturer>
        }
        groupBy: {
          args: Prisma.ManufacturerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ManufacturerGroupByOutputType>[]
        }
        count: {
          args: Prisma.ManufacturerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ManufacturerCountAggregateOutputType> | number
        }
      }
    }
    Category: {
      payload: Prisma.$CategoryPayload<ExtArgs>
      fields: Prisma.CategoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CategoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>
        }
        findFirst: {
          args: Prisma.CategoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>
        }
        findMany: {
          args: Prisma.CategoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>[]
        }
        create: {
          args: Prisma.CategoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>
        }
        createMany: {
          args: Prisma.CategoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>[]
        }
        delete: {
          args: Prisma.CategoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>
        }
        update: {
          args: Prisma.CategoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>
        }
        deleteMany: {
          args: Prisma.CategoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CategoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>[]
        }
        upsert: {
          args: Prisma.CategoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>
        }
        aggregate: {
          args: Prisma.CategoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCategory>
        }
        groupBy: {
          args: Prisma.CategoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CategoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.CategoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CategoryCountAggregateOutputType> | number
        }
      }
    }
    Warehouse: {
      payload: Prisma.$WarehousePayload<ExtArgs>
      fields: Prisma.WarehouseFieldRefs
      operations: {
        findUnique: {
          args: Prisma.WarehouseFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WarehousePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.WarehouseFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WarehousePayload>
        }
        findFirst: {
          args: Prisma.WarehouseFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WarehousePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.WarehouseFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WarehousePayload>
        }
        findMany: {
          args: Prisma.WarehouseFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WarehousePayload>[]
        }
        create: {
          args: Prisma.WarehouseCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WarehousePayload>
        }
        createMany: {
          args: Prisma.WarehouseCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.WarehouseCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WarehousePayload>[]
        }
        delete: {
          args: Prisma.WarehouseDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WarehousePayload>
        }
        update: {
          args: Prisma.WarehouseUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WarehousePayload>
        }
        deleteMany: {
          args: Prisma.WarehouseDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.WarehouseUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.WarehouseUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WarehousePayload>[]
        }
        upsert: {
          args: Prisma.WarehouseUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WarehousePayload>
        }
        aggregate: {
          args: Prisma.WarehouseAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWarehouse>
        }
        groupBy: {
          args: Prisma.WarehouseGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WarehouseGroupByOutputType>[]
        }
        count: {
          args: Prisma.WarehouseCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WarehouseCountAggregateOutputType> | number
        }
      }
    }
    Zone: {
      payload: Prisma.$ZonePayload<ExtArgs>
      fields: Prisma.ZoneFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ZoneFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ZoneFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonePayload>
        }
        findFirst: {
          args: Prisma.ZoneFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ZoneFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonePayload>
        }
        findMany: {
          args: Prisma.ZoneFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonePayload>[]
        }
        create: {
          args: Prisma.ZoneCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonePayload>
        }
        createMany: {
          args: Prisma.ZoneCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ZoneCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonePayload>[]
        }
        delete: {
          args: Prisma.ZoneDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonePayload>
        }
        update: {
          args: Prisma.ZoneUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonePayload>
        }
        deleteMany: {
          args: Prisma.ZoneDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ZoneUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ZoneUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonePayload>[]
        }
        upsert: {
          args: Prisma.ZoneUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonePayload>
        }
        aggregate: {
          args: Prisma.ZoneAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateZone>
        }
        groupBy: {
          args: Prisma.ZoneGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ZoneGroupByOutputType>[]
        }
        count: {
          args: Prisma.ZoneCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ZoneCountAggregateOutputType> | number
        }
      }
    }
    Bin: {
      payload: Prisma.$BinPayload<ExtArgs>
      fields: Prisma.BinFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BinFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BinPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BinFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BinPayload>
        }
        findFirst: {
          args: Prisma.BinFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BinPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BinFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BinPayload>
        }
        findMany: {
          args: Prisma.BinFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BinPayload>[]
        }
        create: {
          args: Prisma.BinCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BinPayload>
        }
        createMany: {
          args: Prisma.BinCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.BinCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BinPayload>[]
        }
        delete: {
          args: Prisma.BinDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BinPayload>
        }
        update: {
          args: Prisma.BinUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BinPayload>
        }
        deleteMany: {
          args: Prisma.BinDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BinUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.BinUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BinPayload>[]
        }
        upsert: {
          args: Prisma.BinUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BinPayload>
        }
        aggregate: {
          args: Prisma.BinAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBin>
        }
        groupBy: {
          args: Prisma.BinGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BinGroupByOutputType>[]
        }
        count: {
          args: Prisma.BinCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BinCountAggregateOutputType> | number
        }
      }
    }
    Volume: {
      payload: Prisma.$VolumePayload<ExtArgs>
      fields: Prisma.VolumeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VolumeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolumePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VolumeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolumePayload>
        }
        findFirst: {
          args: Prisma.VolumeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolumePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VolumeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolumePayload>
        }
        findMany: {
          args: Prisma.VolumeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolumePayload>[]
        }
        create: {
          args: Prisma.VolumeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolumePayload>
        }
        createMany: {
          args: Prisma.VolumeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VolumeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolumePayload>[]
        }
        delete: {
          args: Prisma.VolumeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolumePayload>
        }
        update: {
          args: Prisma.VolumeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolumePayload>
        }
        deleteMany: {
          args: Prisma.VolumeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VolumeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VolumeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolumePayload>[]
        }
        upsert: {
          args: Prisma.VolumeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolumePayload>
        }
        aggregate: {
          args: Prisma.VolumeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVolume>
        }
        groupBy: {
          args: Prisma.VolumeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VolumeGroupByOutputType>[]
        }
        count: {
          args: Prisma.VolumeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VolumeCountAggregateOutputType> | number
        }
      }
    }
    VolumeItem: {
      payload: Prisma.$VolumeItemPayload<ExtArgs>
      fields: Prisma.VolumeItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VolumeItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolumeItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VolumeItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolumeItemPayload>
        }
        findFirst: {
          args: Prisma.VolumeItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolumeItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VolumeItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolumeItemPayload>
        }
        findMany: {
          args: Prisma.VolumeItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolumeItemPayload>[]
        }
        create: {
          args: Prisma.VolumeItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolumeItemPayload>
        }
        createMany: {
          args: Prisma.VolumeItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VolumeItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolumeItemPayload>[]
        }
        delete: {
          args: Prisma.VolumeItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolumeItemPayload>
        }
        update: {
          args: Prisma.VolumeItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolumeItemPayload>
        }
        deleteMany: {
          args: Prisma.VolumeItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VolumeItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VolumeItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolumeItemPayload>[]
        }
        upsert: {
          args: Prisma.VolumeItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolumeItemPayload>
        }
        aggregate: {
          args: Prisma.VolumeItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVolumeItem>
        }
        groupBy: {
          args: Prisma.VolumeItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VolumeItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.VolumeItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VolumeItemCountAggregateOutputType> | number
        }
      }
    }
    Template: {
      payload: Prisma.$TemplatePayload<ExtArgs>
      fields: Prisma.TemplateFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TemplateFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TemplatePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TemplateFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TemplatePayload>
        }
        findFirst: {
          args: Prisma.TemplateFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TemplatePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TemplateFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TemplatePayload>
        }
        findMany: {
          args: Prisma.TemplateFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TemplatePayload>[]
        }
        create: {
          args: Prisma.TemplateCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TemplatePayload>
        }
        createMany: {
          args: Prisma.TemplateCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TemplateCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TemplatePayload>[]
        }
        delete: {
          args: Prisma.TemplateDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TemplatePayload>
        }
        update: {
          args: Prisma.TemplateUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TemplatePayload>
        }
        deleteMany: {
          args: Prisma.TemplateDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TemplateUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TemplateUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TemplatePayload>[]
        }
        upsert: {
          args: Prisma.TemplateUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TemplatePayload>
        }
        aggregate: {
          args: Prisma.TemplateAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTemplate>
        }
        groupBy: {
          args: Prisma.TemplateGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TemplateGroupByOutputType>[]
        }
        count: {
          args: Prisma.TemplateCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TemplateCountAggregateOutputType> | number
        }
      }
    }
    Product: {
      payload: Prisma.$ProductPayload<ExtArgs>
      fields: Prisma.ProductFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProductFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>
        }
        findFirst: {
          args: Prisma.ProductFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>
        }
        findMany: {
          args: Prisma.ProductFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>[]
        }
        create: {
          args: Prisma.ProductCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>
        }
        createMany: {
          args: Prisma.ProductCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>[]
        }
        delete: {
          args: Prisma.ProductDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>
        }
        update: {
          args: Prisma.ProductUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>
        }
        deleteMany: {
          args: Prisma.ProductDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProductUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>[]
        }
        upsert: {
          args: Prisma.ProductUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>
        }
        aggregate: {
          args: Prisma.ProductAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProduct>
        }
        groupBy: {
          args: Prisma.ProductGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProductCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductCountAggregateOutputType> | number
        }
      }
    }
    Variant: {
      payload: Prisma.$VariantPayload<ExtArgs>
      fields: Prisma.VariantFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VariantFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VariantFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantPayload>
        }
        findFirst: {
          args: Prisma.VariantFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VariantFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantPayload>
        }
        findMany: {
          args: Prisma.VariantFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantPayload>[]
        }
        create: {
          args: Prisma.VariantCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantPayload>
        }
        createMany: {
          args: Prisma.VariantCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VariantCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantPayload>[]
        }
        delete: {
          args: Prisma.VariantDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantPayload>
        }
        update: {
          args: Prisma.VariantUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantPayload>
        }
        deleteMany: {
          args: Prisma.VariantDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VariantUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VariantUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantPayload>[]
        }
        upsert: {
          args: Prisma.VariantUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantPayload>
        }
        aggregate: {
          args: Prisma.VariantAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVariant>
        }
        groupBy: {
          args: Prisma.VariantGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VariantGroupByOutputType>[]
        }
        count: {
          args: Prisma.VariantCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VariantCountAggregateOutputType> | number
        }
      }
    }
    Item: {
      payload: Prisma.$ItemPayload<ExtArgs>
      fields: Prisma.ItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemPayload>
        }
        findFirst: {
          args: Prisma.ItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemPayload>
        }
        findMany: {
          args: Prisma.ItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemPayload>[]
        }
        create: {
          args: Prisma.ItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemPayload>
        }
        createMany: {
          args: Prisma.ItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemPayload>[]
        }
        delete: {
          args: Prisma.ItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemPayload>
        }
        update: {
          args: Prisma.ItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemPayload>
        }
        deleteMany: {
          args: Prisma.ItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemPayload>[]
        }
        upsert: {
          args: Prisma.ItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemPayload>
        }
        aggregate: {
          args: Prisma.ItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateItem>
        }
        groupBy: {
          args: Prisma.ItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.ItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ItemCountAggregateOutputType> | number
        }
      }
    }
    ItemMovement: {
      payload: Prisma.$ItemMovementPayload<ExtArgs>
      fields: Prisma.ItemMovementFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ItemMovementFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemMovementPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ItemMovementFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemMovementPayload>
        }
        findFirst: {
          args: Prisma.ItemMovementFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemMovementPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ItemMovementFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemMovementPayload>
        }
        findMany: {
          args: Prisma.ItemMovementFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemMovementPayload>[]
        }
        create: {
          args: Prisma.ItemMovementCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemMovementPayload>
        }
        createMany: {
          args: Prisma.ItemMovementCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ItemMovementCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemMovementPayload>[]
        }
        delete: {
          args: Prisma.ItemMovementDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemMovementPayload>
        }
        update: {
          args: Prisma.ItemMovementUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemMovementPayload>
        }
        deleteMany: {
          args: Prisma.ItemMovementDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ItemMovementUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ItemMovementUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemMovementPayload>[]
        }
        upsert: {
          args: Prisma.ItemMovementUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemMovementPayload>
        }
        aggregate: {
          args: Prisma.ItemMovementAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateItemMovement>
        }
        groupBy: {
          args: Prisma.ItemMovementGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ItemMovementGroupByOutputType>[]
        }
        count: {
          args: Prisma.ItemMovementCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ItemMovementCountAggregateOutputType> | number
        }
      }
    }
    ProductCategory: {
      payload: Prisma.$ProductCategoryPayload<ExtArgs>
      fields: Prisma.ProductCategoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProductCategoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProductCategoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
        }
        findFirst: {
          args: Prisma.ProductCategoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProductCategoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
        }
        findMany: {
          args: Prisma.ProductCategoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
        }
        create: {
          args: Prisma.ProductCategoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
        }
        createMany: {
          args: Prisma.ProductCategoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProductCategoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
        }
        delete: {
          args: Prisma.ProductCategoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
        }
        update: {
          args: Prisma.ProductCategoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
        }
        deleteMany: {
          args: Prisma.ProductCategoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProductCategoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProductCategoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
        }
        upsert: {
          args: Prisma.ProductCategoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
        }
        aggregate: {
          args: Prisma.ProductCategoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProductCategory>
        }
        groupBy: {
          args: Prisma.ProductCategoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductCategoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProductCategoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductCategoryCountAggregateOutputType> | number
        }
      }
    }
    VariantPriceHistory: {
      payload: Prisma.$VariantPriceHistoryPayload<ExtArgs>
      fields: Prisma.VariantPriceHistoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VariantPriceHistoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantPriceHistoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VariantPriceHistoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantPriceHistoryPayload>
        }
        findFirst: {
          args: Prisma.VariantPriceHistoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantPriceHistoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VariantPriceHistoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantPriceHistoryPayload>
        }
        findMany: {
          args: Prisma.VariantPriceHistoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantPriceHistoryPayload>[]
        }
        create: {
          args: Prisma.VariantPriceHistoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantPriceHistoryPayload>
        }
        createMany: {
          args: Prisma.VariantPriceHistoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VariantPriceHistoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantPriceHistoryPayload>[]
        }
        delete: {
          args: Prisma.VariantPriceHistoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantPriceHistoryPayload>
        }
        update: {
          args: Prisma.VariantPriceHistoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantPriceHistoryPayload>
        }
        deleteMany: {
          args: Prisma.VariantPriceHistoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VariantPriceHistoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VariantPriceHistoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantPriceHistoryPayload>[]
        }
        upsert: {
          args: Prisma.VariantPriceHistoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantPriceHistoryPayload>
        }
        aggregate: {
          args: Prisma.VariantPriceHistoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVariantPriceHistory>
        }
        groupBy: {
          args: Prisma.VariantPriceHistoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VariantPriceHistoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.VariantPriceHistoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VariantPriceHistoryCountAggregateOutputType> | number
        }
      }
    }
    AuditLog: {
      payload: Prisma.$AuditLogPayload<ExtArgs>
      fields: Prisma.AuditLogFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        findFirst: {
          args: Prisma.AuditLogFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        findMany: {
          args: Prisma.AuditLogFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
        }
        create: {
          args: Prisma.AuditLogCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        createMany: {
          args: Prisma.AuditLogCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
        }
        delete: {
          args: Prisma.AuditLogDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        update: {
          args: Prisma.AuditLogUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        deleteMany: {
          args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
        }
        upsert: {
          args: Prisma.AuditLogUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        aggregate: {
          args: Prisma.AuditLogAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAuditLog>
        }
        groupBy: {
          args: Prisma.AuditLogGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AuditLogGroupByOutputType>[]
        }
        count: {
          args: Prisma.AuditLogCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AuditLogCountAggregateOutputType> | number
        }
      }
    }
    Tag: {
      payload: Prisma.$TagPayload<ExtArgs>
      fields: Prisma.TagFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TagFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload>
        }
        findFirst: {
          args: Prisma.TagFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload>
        }
        findMany: {
          args: Prisma.TagFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload>[]
        }
        create: {
          args: Prisma.TagCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload>
        }
        createMany: {
          args: Prisma.TagCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload>[]
        }
        delete: {
          args: Prisma.TagDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload>
        }
        update: {
          args: Prisma.TagUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload>
        }
        deleteMany: {
          args: Prisma.TagDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TagUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload>[]
        }
        upsert: {
          args: Prisma.TagUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload>
        }
        aggregate: {
          args: Prisma.TagAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTag>
        }
        groupBy: {
          args: Prisma.TagGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TagGroupByOutputType>[]
        }
        count: {
          args: Prisma.TagCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TagCountAggregateOutputType> | number
        }
      }
    }
    ProductTag: {
      payload: Prisma.$ProductTagPayload<ExtArgs>
      fields: Prisma.ProductTagFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProductTagFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductTagPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProductTagFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductTagPayload>
        }
        findFirst: {
          args: Prisma.ProductTagFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductTagPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProductTagFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductTagPayload>
        }
        findMany: {
          args: Prisma.ProductTagFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductTagPayload>[]
        }
        create: {
          args: Prisma.ProductTagCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductTagPayload>
        }
        createMany: {
          args: Prisma.ProductTagCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProductTagCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductTagPayload>[]
        }
        delete: {
          args: Prisma.ProductTagDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductTagPayload>
        }
        update: {
          args: Prisma.ProductTagUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductTagPayload>
        }
        deleteMany: {
          args: Prisma.ProductTagDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProductTagUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProductTagUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductTagPayload>[]
        }
        upsert: {
          args: Prisma.ProductTagUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductTagPayload>
        }
        aggregate: {
          args: Prisma.ProductTagAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProductTag>
        }
        groupBy: {
          args: Prisma.ProductTagGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductTagGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProductTagCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductTagCountAggregateOutputType> | number
        }
      }
    }
    VariantImage: {
      payload: Prisma.$VariantImagePayload<ExtArgs>
      fields: Prisma.VariantImageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VariantImageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantImagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VariantImageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantImagePayload>
        }
        findFirst: {
          args: Prisma.VariantImageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantImagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VariantImageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantImagePayload>
        }
        findMany: {
          args: Prisma.VariantImageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantImagePayload>[]
        }
        create: {
          args: Prisma.VariantImageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantImagePayload>
        }
        createMany: {
          args: Prisma.VariantImageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VariantImageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantImagePayload>[]
        }
        delete: {
          args: Prisma.VariantImageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantImagePayload>
        }
        update: {
          args: Prisma.VariantImageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantImagePayload>
        }
        deleteMany: {
          args: Prisma.VariantImageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VariantImageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VariantImageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantImagePayload>[]
        }
        upsert: {
          args: Prisma.VariantImageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantImagePayload>
        }
        aggregate: {
          args: Prisma.VariantImageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVariantImage>
        }
        groupBy: {
          args: Prisma.VariantImageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VariantImageGroupByOutputType>[]
        }
        count: {
          args: Prisma.VariantImageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VariantImageCountAggregateOutputType> | number
        }
      }
    }
    Alert: {
      payload: Prisma.$AlertPayload<ExtArgs>
      fields: Prisma.AlertFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AlertFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AlertPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AlertFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AlertPayload>
        }
        findFirst: {
          args: Prisma.AlertFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AlertPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AlertFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AlertPayload>
        }
        findMany: {
          args: Prisma.AlertFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AlertPayload>[]
        }
        create: {
          args: Prisma.AlertCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AlertPayload>
        }
        createMany: {
          args: Prisma.AlertCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AlertCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AlertPayload>[]
        }
        delete: {
          args: Prisma.AlertDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AlertPayload>
        }
        update: {
          args: Prisma.AlertUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AlertPayload>
        }
        deleteMany: {
          args: Prisma.AlertDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AlertUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AlertUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AlertPayload>[]
        }
        upsert: {
          args: Prisma.AlertUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AlertPayload>
        }
        aggregate: {
          args: Prisma.AlertAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAlert>
        }
        groupBy: {
          args: Prisma.AlertGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AlertGroupByOutputType>[]
        }
        count: {
          args: Prisma.AlertCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AlertCountAggregateOutputType> | number
        }
      }
    }
    PurchaseOrder: {
      payload: Prisma.$PurchaseOrderPayload<ExtArgs>
      fields: Prisma.PurchaseOrderFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PurchaseOrderFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
        }
        findFirst: {
          args: Prisma.PurchaseOrderFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PurchaseOrderFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
        }
        findMany: {
          args: Prisma.PurchaseOrderFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
        }
        create: {
          args: Prisma.PurchaseOrderCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
        }
        createMany: {
          args: Prisma.PurchaseOrderCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PurchaseOrderCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
        }
        delete: {
          args: Prisma.PurchaseOrderDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
        }
        update: {
          args: Prisma.PurchaseOrderUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
        }
        deleteMany: {
          args: Prisma.PurchaseOrderDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PurchaseOrderUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PurchaseOrderUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
        }
        upsert: {
          args: Prisma.PurchaseOrderUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
        }
        aggregate: {
          args: Prisma.PurchaseOrderAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePurchaseOrder>
        }
        groupBy: {
          args: Prisma.PurchaseOrderGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PurchaseOrderGroupByOutputType>[]
        }
        count: {
          args: Prisma.PurchaseOrderCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PurchaseOrderCountAggregateOutputType> | number
        }
      }
    }
    PurchaseOrderItem: {
      payload: Prisma.$PurchaseOrderItemPayload<ExtArgs>
      fields: Prisma.PurchaseOrderItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PurchaseOrderItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PurchaseOrderItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
        }
        findFirst: {
          args: Prisma.PurchaseOrderItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PurchaseOrderItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
        }
        findMany: {
          args: Prisma.PurchaseOrderItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>[]
        }
        create: {
          args: Prisma.PurchaseOrderItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
        }
        createMany: {
          args: Prisma.PurchaseOrderItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PurchaseOrderItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>[]
        }
        delete: {
          args: Prisma.PurchaseOrderItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
        }
        update: {
          args: Prisma.PurchaseOrderItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
        }
        deleteMany: {
          args: Prisma.PurchaseOrderItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PurchaseOrderItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PurchaseOrderItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>[]
        }
        upsert: {
          args: Prisma.PurchaseOrderItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
        }
        aggregate: {
          args: Prisma.PurchaseOrderItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePurchaseOrderItem>
        }
        groupBy: {
          args: Prisma.PurchaseOrderItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PurchaseOrderItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.PurchaseOrderItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PurchaseOrderItemCountAggregateOutputType> | number
        }
      }
    }
    UnitConversion: {
      payload: Prisma.$UnitConversionPayload<ExtArgs>
      fields: Prisma.UnitConversionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UnitConversionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitConversionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UnitConversionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitConversionPayload>
        }
        findFirst: {
          args: Prisma.UnitConversionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitConversionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UnitConversionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitConversionPayload>
        }
        findMany: {
          args: Prisma.UnitConversionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitConversionPayload>[]
        }
        create: {
          args: Prisma.UnitConversionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitConversionPayload>
        }
        createMany: {
          args: Prisma.UnitConversionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UnitConversionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitConversionPayload>[]
        }
        delete: {
          args: Prisma.UnitConversionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitConversionPayload>
        }
        update: {
          args: Prisma.UnitConversionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitConversionPayload>
        }
        deleteMany: {
          args: Prisma.UnitConversionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UnitConversionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UnitConversionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitConversionPayload>[]
        }
        upsert: {
          args: Prisma.UnitConversionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitConversionPayload>
        }
        aggregate: {
          args: Prisma.UnitConversionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUnitConversion>
        }
        groupBy: {
          args: Prisma.UnitConversionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UnitConversionGroupByOutputType>[]
        }
        count: {
          args: Prisma.UnitConversionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UnitConversionCountAggregateOutputType> | number
        }
      }
    }
    StockSnapshot: {
      payload: Prisma.$StockSnapshotPayload<ExtArgs>
      fields: Prisma.StockSnapshotFieldRefs
      operations: {
        findUnique: {
          args: Prisma.StockSnapshotFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockSnapshotPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.StockSnapshotFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockSnapshotPayload>
        }
        findFirst: {
          args: Prisma.StockSnapshotFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockSnapshotPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.StockSnapshotFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockSnapshotPayload>
        }
        findMany: {
          args: Prisma.StockSnapshotFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockSnapshotPayload>[]
        }
        create: {
          args: Prisma.StockSnapshotCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockSnapshotPayload>
        }
        createMany: {
          args: Prisma.StockSnapshotCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.StockSnapshotCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockSnapshotPayload>[]
        }
        delete: {
          args: Prisma.StockSnapshotDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockSnapshotPayload>
        }
        update: {
          args: Prisma.StockSnapshotUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockSnapshotPayload>
        }
        deleteMany: {
          args: Prisma.StockSnapshotDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.StockSnapshotUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.StockSnapshotUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockSnapshotPayload>[]
        }
        upsert: {
          args: Prisma.StockSnapshotUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockSnapshotPayload>
        }
        aggregate: {
          args: Prisma.StockSnapshotAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateStockSnapshot>
        }
        groupBy: {
          args: Prisma.StockSnapshotGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StockSnapshotGroupByOutputType>[]
        }
        count: {
          args: Prisma.StockSnapshotCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StockSnapshotCountAggregateOutputType> | number
        }
      }
    }
    Customer: {
      payload: Prisma.$CustomerPayload<ExtArgs>
      fields: Prisma.CustomerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CustomerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        findFirst: {
          args: Prisma.CustomerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        findMany: {
          args: Prisma.CustomerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>[]
        }
        create: {
          args: Prisma.CustomerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        createMany: {
          args: Prisma.CustomerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>[]
        }
        delete: {
          args: Prisma.CustomerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        update: {
          args: Prisma.CustomerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        deleteMany: {
          args: Prisma.CustomerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CustomerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>[]
        }
        upsert: {
          args: Prisma.CustomerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        aggregate: {
          args: Prisma.CustomerAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCustomer>
        }
        groupBy: {
          args: Prisma.CustomerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomerGroupByOutputType>[]
        }
        count: {
          args: Prisma.CustomerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomerCountAggregateOutputType> | number
        }
      }
    }
    SalesOrder: {
      payload: Prisma.$SalesOrderPayload<ExtArgs>
      fields: Prisma.SalesOrderFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SalesOrderFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalesOrderPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SalesOrderFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalesOrderPayload>
        }
        findFirst: {
          args: Prisma.SalesOrderFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalesOrderPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SalesOrderFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalesOrderPayload>
        }
        findMany: {
          args: Prisma.SalesOrderFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalesOrderPayload>[]
        }
        create: {
          args: Prisma.SalesOrderCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalesOrderPayload>
        }
        createMany: {
          args: Prisma.SalesOrderCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SalesOrderCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalesOrderPayload>[]
        }
        delete: {
          args: Prisma.SalesOrderDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalesOrderPayload>
        }
        update: {
          args: Prisma.SalesOrderUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalesOrderPayload>
        }
        deleteMany: {
          args: Prisma.SalesOrderDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SalesOrderUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SalesOrderUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalesOrderPayload>[]
        }
        upsert: {
          args: Prisma.SalesOrderUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalesOrderPayload>
        }
        aggregate: {
          args: Prisma.SalesOrderAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSalesOrder>
        }
        groupBy: {
          args: Prisma.SalesOrderGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SalesOrderGroupByOutputType>[]
        }
        count: {
          args: Prisma.SalesOrderCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SalesOrderCountAggregateOutputType> | number
        }
      }
    }
    SalesOrderItem: {
      payload: Prisma.$SalesOrderItemPayload<ExtArgs>
      fields: Prisma.SalesOrderItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SalesOrderItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalesOrderItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SalesOrderItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalesOrderItemPayload>
        }
        findFirst: {
          args: Prisma.SalesOrderItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalesOrderItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SalesOrderItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalesOrderItemPayload>
        }
        findMany: {
          args: Prisma.SalesOrderItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalesOrderItemPayload>[]
        }
        create: {
          args: Prisma.SalesOrderItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalesOrderItemPayload>
        }
        createMany: {
          args: Prisma.SalesOrderItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SalesOrderItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalesOrderItemPayload>[]
        }
        delete: {
          args: Prisma.SalesOrderItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalesOrderItemPayload>
        }
        update: {
          args: Prisma.SalesOrderItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalesOrderItemPayload>
        }
        deleteMany: {
          args: Prisma.SalesOrderItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SalesOrderItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SalesOrderItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalesOrderItemPayload>[]
        }
        upsert: {
          args: Prisma.SalesOrderItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalesOrderItemPayload>
        }
        aggregate: {
          args: Prisma.SalesOrderItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSalesOrderItem>
        }
        groupBy: {
          args: Prisma.SalesOrderItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SalesOrderItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.SalesOrderItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SalesOrderItemCountAggregateOutputType> | number
        }
      }
    }
    ItemReservation: {
      payload: Prisma.$ItemReservationPayload<ExtArgs>
      fields: Prisma.ItemReservationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ItemReservationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemReservationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ItemReservationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemReservationPayload>
        }
        findFirst: {
          args: Prisma.ItemReservationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemReservationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ItemReservationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemReservationPayload>
        }
        findMany: {
          args: Prisma.ItemReservationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemReservationPayload>[]
        }
        create: {
          args: Prisma.ItemReservationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemReservationPayload>
        }
        createMany: {
          args: Prisma.ItemReservationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ItemReservationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemReservationPayload>[]
        }
        delete: {
          args: Prisma.ItemReservationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemReservationPayload>
        }
        update: {
          args: Prisma.ItemReservationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemReservationPayload>
        }
        deleteMany: {
          args: Prisma.ItemReservationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ItemReservationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ItemReservationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemReservationPayload>[]
        }
        upsert: {
          args: Prisma.ItemReservationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemReservationPayload>
        }
        aggregate: {
          args: Prisma.ItemReservationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateItemReservation>
        }
        groupBy: {
          args: Prisma.ItemReservationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ItemReservationGroupByOutputType>[]
        }
        count: {
          args: Prisma.ItemReservationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ItemReservationCountAggregateOutputType> | number
        }
      }
    }
    VariantSupplierCode: {
      payload: Prisma.$VariantSupplierCodePayload<ExtArgs>
      fields: Prisma.VariantSupplierCodeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VariantSupplierCodeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantSupplierCodePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VariantSupplierCodeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantSupplierCodePayload>
        }
        findFirst: {
          args: Prisma.VariantSupplierCodeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantSupplierCodePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VariantSupplierCodeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantSupplierCodePayload>
        }
        findMany: {
          args: Prisma.VariantSupplierCodeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantSupplierCodePayload>[]
        }
        create: {
          args: Prisma.VariantSupplierCodeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantSupplierCodePayload>
        }
        createMany: {
          args: Prisma.VariantSupplierCodeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VariantSupplierCodeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantSupplierCodePayload>[]
        }
        delete: {
          args: Prisma.VariantSupplierCodeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantSupplierCodePayload>
        }
        update: {
          args: Prisma.VariantSupplierCodeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantSupplierCodePayload>
        }
        deleteMany: {
          args: Prisma.VariantSupplierCodeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VariantSupplierCodeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VariantSupplierCodeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantSupplierCodePayload>[]
        }
        upsert: {
          args: Prisma.VariantSupplierCodeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantSupplierCodePayload>
        }
        aggregate: {
          args: Prisma.VariantSupplierCodeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVariantSupplierCode>
        }
        groupBy: {
          args: Prisma.VariantSupplierCodeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VariantSupplierCodeGroupByOutputType>[]
        }
        count: {
          args: Prisma.VariantSupplierCodeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VariantSupplierCodeCountAggregateOutputType> | number
        }
      }
    }
    VariantPromotion: {
      payload: Prisma.$VariantPromotionPayload<ExtArgs>
      fields: Prisma.VariantPromotionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VariantPromotionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantPromotionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VariantPromotionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantPromotionPayload>
        }
        findFirst: {
          args: Prisma.VariantPromotionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantPromotionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VariantPromotionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantPromotionPayload>
        }
        findMany: {
          args: Prisma.VariantPromotionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantPromotionPayload>[]
        }
        create: {
          args: Prisma.VariantPromotionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantPromotionPayload>
        }
        createMany: {
          args: Prisma.VariantPromotionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VariantPromotionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantPromotionPayload>[]
        }
        delete: {
          args: Prisma.VariantPromotionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantPromotionPayload>
        }
        update: {
          args: Prisma.VariantPromotionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantPromotionPayload>
        }
        deleteMany: {
          args: Prisma.VariantPromotionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VariantPromotionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VariantPromotionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantPromotionPayload>[]
        }
        upsert: {
          args: Prisma.VariantPromotionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantPromotionPayload>
        }
        aggregate: {
          args: Prisma.VariantPromotionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVariantPromotion>
        }
        groupBy: {
          args: Prisma.VariantPromotionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VariantPromotionGroupByOutputType>[]
        }
        count: {
          args: Prisma.VariantPromotionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VariantPromotionCountAggregateOutputType> | number
        }
      }
    }
    Comment: {
      payload: Prisma.$CommentPayload<ExtArgs>
      fields: Prisma.CommentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CommentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        findFirst: {
          args: Prisma.CommentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        findMany: {
          args: Prisma.CommentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>[]
        }
        create: {
          args: Prisma.CommentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        createMany: {
          args: Prisma.CommentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>[]
        }
        delete: {
          args: Prisma.CommentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        update: {
          args: Prisma.CommentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        deleteMany: {
          args: Prisma.CommentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CommentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>[]
        }
        upsert: {
          args: Prisma.CommentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        aggregate: {
          args: Prisma.CommentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateComment>
        }
        groupBy: {
          args: Prisma.CommentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommentGroupByOutputType>[]
        }
        count: {
          args: Prisma.CommentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommentCountAggregateOutputType> | number
        }
      }
    }
    NotificationPreference: {
      payload: Prisma.$NotificationPreferencePayload<ExtArgs>
      fields: Prisma.NotificationPreferenceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NotificationPreferenceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
        }
        findFirst: {
          args: Prisma.NotificationPreferenceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
        }
        findMany: {
          args: Prisma.NotificationPreferenceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
        }
        create: {
          args: Prisma.NotificationPreferenceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
        }
        createMany: {
          args: Prisma.NotificationPreferenceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
        }
        delete: {
          args: Prisma.NotificationPreferenceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
        }
        update: {
          args: Prisma.NotificationPreferenceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
        }
        deleteMany: {
          args: Prisma.NotificationPreferenceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NotificationPreferenceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
        }
        upsert: {
          args: Prisma.NotificationPreferenceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
        }
        aggregate: {
          args: Prisma.NotificationPreferenceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNotificationPreference>
        }
        groupBy: {
          args: Prisma.NotificationPreferenceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationPreferenceGroupByOutputType>[]
        }
        count: {
          args: Prisma.NotificationPreferenceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationPreferenceCountAggregateOutputType> | number
        }
      }
    }
    NotificationTemplate: {
      payload: Prisma.$NotificationTemplatePayload<ExtArgs>
      fields: Prisma.NotificationTemplateFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NotificationTemplateFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationTemplatePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NotificationTemplateFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>
        }
        findFirst: {
          args: Prisma.NotificationTemplateFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationTemplatePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NotificationTemplateFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>
        }
        findMany: {
          args: Prisma.NotificationTemplateFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>[]
        }
        create: {
          args: Prisma.NotificationTemplateCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>
        }
        createMany: {
          args: Prisma.NotificationTemplateCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NotificationTemplateCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>[]
        }
        delete: {
          args: Prisma.NotificationTemplateDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>
        }
        update: {
          args: Prisma.NotificationTemplateUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>
        }
        deleteMany: {
          args: Prisma.NotificationTemplateDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NotificationTemplateUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NotificationTemplateUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>[]
        }
        upsert: {
          args: Prisma.NotificationTemplateUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>
        }
        aggregate: {
          args: Prisma.NotificationTemplateAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNotificationTemplate>
        }
        groupBy: {
          args: Prisma.NotificationTemplateGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationTemplateGroupByOutputType>[]
        }
        count: {
          args: Prisma.NotificationTemplateCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationTemplateCountAggregateOutputType> | number
        }
      }
    }
    Notification: {
      payload: Prisma.$NotificationPayload<ExtArgs>
      fields: Prisma.NotificationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NotificationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        findFirst: {
          args: Prisma.NotificationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        findMany: {
          args: Prisma.NotificationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>[]
        }
        create: {
          args: Prisma.NotificationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        createMany: {
          args: Prisma.NotificationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>[]
        }
        delete: {
          args: Prisma.NotificationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        update: {
          args: Prisma.NotificationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        deleteMany: {
          args: Prisma.NotificationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NotificationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>[]
        }
        upsert: {
          args: Prisma.NotificationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        aggregate: {
          args: Prisma.NotificationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNotification>
        }
        groupBy: {
          args: Prisma.NotificationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationGroupByOutputType>[]
        }
        count: {
          args: Prisma.NotificationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationCountAggregateOutputType> | number
        }
      }
    }
    Request: {
      payload: Prisma.$RequestPayload<ExtArgs>
      fields: Prisma.RequestFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RequestFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RequestFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestPayload>
        }
        findFirst: {
          args: Prisma.RequestFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RequestFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestPayload>
        }
        findMany: {
          args: Prisma.RequestFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestPayload>[]
        }
        create: {
          args: Prisma.RequestCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestPayload>
        }
        createMany: {
          args: Prisma.RequestCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RequestCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestPayload>[]
        }
        delete: {
          args: Prisma.RequestDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestPayload>
        }
        update: {
          args: Prisma.RequestUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestPayload>
        }
        deleteMany: {
          args: Prisma.RequestDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RequestUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RequestUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestPayload>[]
        }
        upsert: {
          args: Prisma.RequestUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestPayload>
        }
        aggregate: {
          args: Prisma.RequestAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRequest>
        }
        groupBy: {
          args: Prisma.RequestGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RequestGroupByOutputType>[]
        }
        count: {
          args: Prisma.RequestCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RequestCountAggregateOutputType> | number
        }
      }
    }
    RequestAttachment: {
      payload: Prisma.$RequestAttachmentPayload<ExtArgs>
      fields: Prisma.RequestAttachmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RequestAttachmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestAttachmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RequestAttachmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestAttachmentPayload>
        }
        findFirst: {
          args: Prisma.RequestAttachmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestAttachmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RequestAttachmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestAttachmentPayload>
        }
        findMany: {
          args: Prisma.RequestAttachmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestAttachmentPayload>[]
        }
        create: {
          args: Prisma.RequestAttachmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestAttachmentPayload>
        }
        createMany: {
          args: Prisma.RequestAttachmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RequestAttachmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestAttachmentPayload>[]
        }
        delete: {
          args: Prisma.RequestAttachmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestAttachmentPayload>
        }
        update: {
          args: Prisma.RequestAttachmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestAttachmentPayload>
        }
        deleteMany: {
          args: Prisma.RequestAttachmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RequestAttachmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RequestAttachmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestAttachmentPayload>[]
        }
        upsert: {
          args: Prisma.RequestAttachmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestAttachmentPayload>
        }
        aggregate: {
          args: Prisma.RequestAttachmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRequestAttachment>
        }
        groupBy: {
          args: Prisma.RequestAttachmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RequestAttachmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.RequestAttachmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RequestAttachmentCountAggregateOutputType> | number
        }
      }
    }
    RequestComment: {
      payload: Prisma.$RequestCommentPayload<ExtArgs>
      fields: Prisma.RequestCommentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RequestCommentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestCommentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RequestCommentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestCommentPayload>
        }
        findFirst: {
          args: Prisma.RequestCommentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestCommentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RequestCommentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestCommentPayload>
        }
        findMany: {
          args: Prisma.RequestCommentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestCommentPayload>[]
        }
        create: {
          args: Prisma.RequestCommentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestCommentPayload>
        }
        createMany: {
          args: Prisma.RequestCommentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RequestCommentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestCommentPayload>[]
        }
        delete: {
          args: Prisma.RequestCommentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestCommentPayload>
        }
        update: {
          args: Prisma.RequestCommentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestCommentPayload>
        }
        deleteMany: {
          args: Prisma.RequestCommentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RequestCommentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RequestCommentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestCommentPayload>[]
        }
        upsert: {
          args: Prisma.RequestCommentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestCommentPayload>
        }
        aggregate: {
          args: Prisma.RequestCommentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRequestComment>
        }
        groupBy: {
          args: Prisma.RequestCommentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RequestCommentGroupByOutputType>[]
        }
        count: {
          args: Prisma.RequestCommentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RequestCommentCountAggregateOutputType> | number
        }
      }
    }
    RequestHistory: {
      payload: Prisma.$RequestHistoryPayload<ExtArgs>
      fields: Prisma.RequestHistoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RequestHistoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestHistoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RequestHistoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestHistoryPayload>
        }
        findFirst: {
          args: Prisma.RequestHistoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestHistoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RequestHistoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestHistoryPayload>
        }
        findMany: {
          args: Prisma.RequestHistoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestHistoryPayload>[]
        }
        create: {
          args: Prisma.RequestHistoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestHistoryPayload>
        }
        createMany: {
          args: Prisma.RequestHistoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RequestHistoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestHistoryPayload>[]
        }
        delete: {
          args: Prisma.RequestHistoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestHistoryPayload>
        }
        update: {
          args: Prisma.RequestHistoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestHistoryPayload>
        }
        deleteMany: {
          args: Prisma.RequestHistoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RequestHistoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RequestHistoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestHistoryPayload>[]
        }
        upsert: {
          args: Prisma.RequestHistoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequestHistoryPayload>
        }
        aggregate: {
          args: Prisma.RequestHistoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRequestHistory>
        }
        groupBy: {
          args: Prisma.RequestHistoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RequestHistoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.RequestHistoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RequestHistoryCountAggregateOutputType> | number
        }
      }
    }
    Employee: {
      payload: Prisma.$EmployeePayload<ExtArgs>
      fields: Prisma.EmployeeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload>
        }
        findFirst: {
          args: Prisma.EmployeeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload>
        }
        findMany: {
          args: Prisma.EmployeeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload>[]
        }
        create: {
          args: Prisma.EmployeeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload>
        }
        createMany: {
          args: Prisma.EmployeeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EmployeeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload>[]
        }
        delete: {
          args: Prisma.EmployeeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload>
        }
        update: {
          args: Prisma.EmployeeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload>
        }
        deleteMany: {
          args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EmployeeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload>[]
        }
        upsert: {
          args: Prisma.EmployeeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload>
        }
        aggregate: {
          args: Prisma.EmployeeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEmployee>
        }
        groupBy: {
          args: Prisma.EmployeeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EmployeeGroupByOutputType>[]
        }
        count: {
          args: Prisma.EmployeeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EmployeeCountAggregateOutputType> | number
        }
      }
    }
    Department: {
      payload: Prisma.$DepartmentPayload<ExtArgs>
      fields: Prisma.DepartmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload>
        }
        findFirst: {
          args: Prisma.DepartmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload>
        }
        findMany: {
          args: Prisma.DepartmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
        }
        create: {
          args: Prisma.DepartmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload>
        }
        createMany: {
          args: Prisma.DepartmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DepartmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
        }
        delete: {
          args: Prisma.DepartmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload>
        }
        update: {
          args: Prisma.DepartmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload>
        }
        deleteMany: {
          args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DepartmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
        }
        upsert: {
          args: Prisma.DepartmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload>
        }
        aggregate: {
          args: Prisma.DepartmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDepartment>
        }
        groupBy: {
          args: Prisma.DepartmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DepartmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.DepartmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DepartmentCountAggregateOutputType> | number
        }
      }
    }
    Position: {
      payload: Prisma.$PositionPayload<ExtArgs>
      fields: Prisma.PositionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PositionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PositionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PositionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PositionPayload>
        }
        findFirst: {
          args: Prisma.PositionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PositionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PositionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PositionPayload>
        }
        findMany: {
          args: Prisma.PositionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PositionPayload>[]
        }
        create: {
          args: Prisma.PositionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PositionPayload>
        }
        createMany: {
          args: Prisma.PositionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PositionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PositionPayload>[]
        }
        delete: {
          args: Prisma.PositionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PositionPayload>
        }
        update: {
          args: Prisma.PositionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PositionPayload>
        }
        deleteMany: {
          args: Prisma.PositionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PositionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PositionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PositionPayload>[]
        }
        upsert: {
          args: Prisma.PositionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PositionPayload>
        }
        aggregate: {
          args: Prisma.PositionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePosition>
        }
        groupBy: {
          args: Prisma.PositionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PositionGroupByOutputType>[]
        }
        count: {
          args: Prisma.PositionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PositionCountAggregateOutputType> | number
        }
      }
    }
    TimeEntry: {
      payload: Prisma.$TimeEntryPayload<ExtArgs>
      fields: Prisma.TimeEntryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TimeEntryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeEntryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TimeEntryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeEntryPayload>
        }
        findFirst: {
          args: Prisma.TimeEntryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeEntryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TimeEntryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeEntryPayload>
        }
        findMany: {
          args: Prisma.TimeEntryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeEntryPayload>[]
        }
        create: {
          args: Prisma.TimeEntryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeEntryPayload>
        }
        createMany: {
          args: Prisma.TimeEntryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TimeEntryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeEntryPayload>[]
        }
        delete: {
          args: Prisma.TimeEntryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeEntryPayload>
        }
        update: {
          args: Prisma.TimeEntryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeEntryPayload>
        }
        deleteMany: {
          args: Prisma.TimeEntryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TimeEntryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TimeEntryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeEntryPayload>[]
        }
        upsert: {
          args: Prisma.TimeEntryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeEntryPayload>
        }
        aggregate: {
          args: Prisma.TimeEntryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTimeEntry>
        }
        groupBy: {
          args: Prisma.TimeEntryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TimeEntryGroupByOutputType>[]
        }
        count: {
          args: Prisma.TimeEntryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TimeEntryCountAggregateOutputType> | number
        }
      }
    }
    WorkSchedule: {
      payload: Prisma.$WorkSchedulePayload<ExtArgs>
      fields: Prisma.WorkScheduleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.WorkScheduleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkSchedulePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.WorkScheduleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkSchedulePayload>
        }
        findFirst: {
          args: Prisma.WorkScheduleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkSchedulePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.WorkScheduleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkSchedulePayload>
        }
        findMany: {
          args: Prisma.WorkScheduleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkSchedulePayload>[]
        }
        create: {
          args: Prisma.WorkScheduleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkSchedulePayload>
        }
        createMany: {
          args: Prisma.WorkScheduleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.WorkScheduleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkSchedulePayload>[]
        }
        delete: {
          args: Prisma.WorkScheduleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkSchedulePayload>
        }
        update: {
          args: Prisma.WorkScheduleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkSchedulePayload>
        }
        deleteMany: {
          args: Prisma.WorkScheduleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.WorkScheduleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.WorkScheduleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkSchedulePayload>[]
        }
        upsert: {
          args: Prisma.WorkScheduleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkSchedulePayload>
        }
        aggregate: {
          args: Prisma.WorkScheduleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWorkSchedule>
        }
        groupBy: {
          args: Prisma.WorkScheduleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WorkScheduleGroupByOutputType>[]
        }
        count: {
          args: Prisma.WorkScheduleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WorkScheduleCountAggregateOutputType> | number
        }
      }
    }
    Overtime: {
      payload: Prisma.$OvertimePayload<ExtArgs>
      fields: Prisma.OvertimeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OvertimeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OvertimePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OvertimeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OvertimePayload>
        }
        findFirst: {
          args: Prisma.OvertimeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OvertimePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OvertimeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OvertimePayload>
        }
        findMany: {
          args: Prisma.OvertimeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OvertimePayload>[]
        }
        create: {
          args: Prisma.OvertimeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OvertimePayload>
        }
        createMany: {
          args: Prisma.OvertimeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OvertimeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OvertimePayload>[]
        }
        delete: {
          args: Prisma.OvertimeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OvertimePayload>
        }
        update: {
          args: Prisma.OvertimeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OvertimePayload>
        }
        deleteMany: {
          args: Prisma.OvertimeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OvertimeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OvertimeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OvertimePayload>[]
        }
        upsert: {
          args: Prisma.OvertimeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OvertimePayload>
        }
        aggregate: {
          args: Prisma.OvertimeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOvertime>
        }
        groupBy: {
          args: Prisma.OvertimeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OvertimeGroupByOutputType>[]
        }
        count: {
          args: Prisma.OvertimeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OvertimeCountAggregateOutputType> | number
        }
      }
    }
    TimeBank: {
      payload: Prisma.$TimeBankPayload<ExtArgs>
      fields: Prisma.TimeBankFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TimeBankFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeBankPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TimeBankFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeBankPayload>
        }
        findFirst: {
          args: Prisma.TimeBankFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeBankPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TimeBankFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeBankPayload>
        }
        findMany: {
          args: Prisma.TimeBankFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeBankPayload>[]
        }
        create: {
          args: Prisma.TimeBankCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeBankPayload>
        }
        createMany: {
          args: Prisma.TimeBankCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TimeBankCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeBankPayload>[]
        }
        delete: {
          args: Prisma.TimeBankDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeBankPayload>
        }
        update: {
          args: Prisma.TimeBankUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeBankPayload>
        }
        deleteMany: {
          args: Prisma.TimeBankDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TimeBankUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TimeBankUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeBankPayload>[]
        }
        upsert: {
          args: Prisma.TimeBankUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeBankPayload>
        }
        aggregate: {
          args: Prisma.TimeBankAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTimeBank>
        }
        groupBy: {
          args: Prisma.TimeBankGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TimeBankGroupByOutputType>[]
        }
        count: {
          args: Prisma.TimeBankCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TimeBankCountAggregateOutputType> | number
        }
      }
    }
    Absence: {
      payload: Prisma.$AbsencePayload<ExtArgs>
      fields: Prisma.AbsenceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AbsenceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AbsencePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AbsenceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AbsencePayload>
        }
        findFirst: {
          args: Prisma.AbsenceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AbsencePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AbsenceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AbsencePayload>
        }
        findMany: {
          args: Prisma.AbsenceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AbsencePayload>[]
        }
        create: {
          args: Prisma.AbsenceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AbsencePayload>
        }
        createMany: {
          args: Prisma.AbsenceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AbsenceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AbsencePayload>[]
        }
        delete: {
          args: Prisma.AbsenceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AbsencePayload>
        }
        update: {
          args: Prisma.AbsenceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AbsencePayload>
        }
        deleteMany: {
          args: Prisma.AbsenceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AbsenceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AbsenceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AbsencePayload>[]
        }
        upsert: {
          args: Prisma.AbsenceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AbsencePayload>
        }
        aggregate: {
          args: Prisma.AbsenceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAbsence>
        }
        groupBy: {
          args: Prisma.AbsenceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AbsenceGroupByOutputType>[]
        }
        count: {
          args: Prisma.AbsenceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AbsenceCountAggregateOutputType> | number
        }
      }
    }
    VacationPeriod: {
      payload: Prisma.$VacationPeriodPayload<ExtArgs>
      fields: Prisma.VacationPeriodFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VacationPeriodFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VacationPeriodPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VacationPeriodFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VacationPeriodPayload>
        }
        findFirst: {
          args: Prisma.VacationPeriodFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VacationPeriodPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VacationPeriodFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VacationPeriodPayload>
        }
        findMany: {
          args: Prisma.VacationPeriodFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VacationPeriodPayload>[]
        }
        create: {
          args: Prisma.VacationPeriodCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VacationPeriodPayload>
        }
        createMany: {
          args: Prisma.VacationPeriodCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VacationPeriodCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VacationPeriodPayload>[]
        }
        delete: {
          args: Prisma.VacationPeriodDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VacationPeriodPayload>
        }
        update: {
          args: Prisma.VacationPeriodUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VacationPeriodPayload>
        }
        deleteMany: {
          args: Prisma.VacationPeriodDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VacationPeriodUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VacationPeriodUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VacationPeriodPayload>[]
        }
        upsert: {
          args: Prisma.VacationPeriodUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VacationPeriodPayload>
        }
        aggregate: {
          args: Prisma.VacationPeriodAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVacationPeriod>
        }
        groupBy: {
          args: Prisma.VacationPeriodGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VacationPeriodGroupByOutputType>[]
        }
        count: {
          args: Prisma.VacationPeriodCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VacationPeriodCountAggregateOutputType> | number
        }
      }
    }
    Payroll: {
      payload: Prisma.$PayrollPayload<ExtArgs>
      fields: Prisma.PayrollFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PayrollFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PayrollFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPayload>
        }
        findFirst: {
          args: Prisma.PayrollFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PayrollFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPayload>
        }
        findMany: {
          args: Prisma.PayrollFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPayload>[]
        }
        create: {
          args: Prisma.PayrollCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPayload>
        }
        createMany: {
          args: Prisma.PayrollCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PayrollCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPayload>[]
        }
        delete: {
          args: Prisma.PayrollDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPayload>
        }
        update: {
          args: Prisma.PayrollUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPayload>
        }
        deleteMany: {
          args: Prisma.PayrollDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PayrollUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PayrollUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPayload>[]
        }
        upsert: {
          args: Prisma.PayrollUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPayload>
        }
        aggregate: {
          args: Prisma.PayrollAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePayroll>
        }
        groupBy: {
          args: Prisma.PayrollGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PayrollGroupByOutputType>[]
        }
        count: {
          args: Prisma.PayrollCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PayrollCountAggregateOutputType> | number
        }
      }
    }
    PayrollItem: {
      payload: Prisma.$PayrollItemPayload<ExtArgs>
      fields: Prisma.PayrollItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PayrollItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PayrollItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollItemPayload>
        }
        findFirst: {
          args: Prisma.PayrollItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PayrollItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollItemPayload>
        }
        findMany: {
          args: Prisma.PayrollItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollItemPayload>[]
        }
        create: {
          args: Prisma.PayrollItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollItemPayload>
        }
        createMany: {
          args: Prisma.PayrollItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PayrollItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollItemPayload>[]
        }
        delete: {
          args: Prisma.PayrollItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollItemPayload>
        }
        update: {
          args: Prisma.PayrollItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollItemPayload>
        }
        deleteMany: {
          args: Prisma.PayrollItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PayrollItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PayrollItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollItemPayload>[]
        }
        upsert: {
          args: Prisma.PayrollItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollItemPayload>
        }
        aggregate: {
          args: Prisma.PayrollItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePayrollItem>
        }
        groupBy: {
          args: Prisma.PayrollItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PayrollItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.PayrollItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PayrollItemCountAggregateOutputType> | number
        }
      }
    }
    Bonus: {
      payload: Prisma.$BonusPayload<ExtArgs>
      fields: Prisma.BonusFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BonusFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BonusPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BonusFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BonusPayload>
        }
        findFirst: {
          args: Prisma.BonusFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BonusPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BonusFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BonusPayload>
        }
        findMany: {
          args: Prisma.BonusFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BonusPayload>[]
        }
        create: {
          args: Prisma.BonusCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BonusPayload>
        }
        createMany: {
          args: Prisma.BonusCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.BonusCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BonusPayload>[]
        }
        delete: {
          args: Prisma.BonusDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BonusPayload>
        }
        update: {
          args: Prisma.BonusUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BonusPayload>
        }
        deleteMany: {
          args: Prisma.BonusDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BonusUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.BonusUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BonusPayload>[]
        }
        upsert: {
          args: Prisma.BonusUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BonusPayload>
        }
        aggregate: {
          args: Prisma.BonusAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBonus>
        }
        groupBy: {
          args: Prisma.BonusGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BonusGroupByOutputType>[]
        }
        count: {
          args: Prisma.BonusCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BonusCountAggregateOutputType> | number
        }
      }
    }
    Deduction: {
      payload: Prisma.$DeductionPayload<ExtArgs>
      fields: Prisma.DeductionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DeductionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeductionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DeductionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeductionPayload>
        }
        findFirst: {
          args: Prisma.DeductionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeductionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DeductionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeductionPayload>
        }
        findMany: {
          args: Prisma.DeductionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeductionPayload>[]
        }
        create: {
          args: Prisma.DeductionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeductionPayload>
        }
        createMany: {
          args: Prisma.DeductionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DeductionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeductionPayload>[]
        }
        delete: {
          args: Prisma.DeductionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeductionPayload>
        }
        update: {
          args: Prisma.DeductionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeductionPayload>
        }
        deleteMany: {
          args: Prisma.DeductionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DeductionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DeductionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeductionPayload>[]
        }
        upsert: {
          args: Prisma.DeductionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeductionPayload>
        }
        aggregate: {
          args: Prisma.DeductionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDeduction>
        }
        groupBy: {
          args: Prisma.DeductionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DeductionGroupByOutputType>[]
        }
        count: {
          args: Prisma.DeductionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DeductionCountAggregateOutputType> | number
        }
      }
    }
    Company: {
      payload: Prisma.$CompanyPayload<ExtArgs>
      fields: Prisma.CompanyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CompanyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>
        }
        findFirst: {
          args: Prisma.CompanyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>
        }
        findMany: {
          args: Prisma.CompanyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>[]
        }
        create: {
          args: Prisma.CompanyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>
        }
        createMany: {
          args: Prisma.CompanyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>[]
        }
        delete: {
          args: Prisma.CompanyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>
        }
        update: {
          args: Prisma.CompanyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>
        }
        deleteMany: {
          args: Prisma.CompanyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CompanyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CompanyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>[]
        }
        upsert: {
          args: Prisma.CompanyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>
        }
        aggregate: {
          args: Prisma.CompanyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCompany>
        }
        groupBy: {
          args: Prisma.CompanyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompanyGroupByOutputType>[]
        }
        count: {
          args: Prisma.CompanyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompanyCountAggregateOutputType> | number
        }
      }
    }
    CompanyAddress: {
      payload: Prisma.$CompanyAddressPayload<ExtArgs>
      fields: Prisma.CompanyAddressFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CompanyAddressFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyAddressPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CompanyAddressFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyAddressPayload>
        }
        findFirst: {
          args: Prisma.CompanyAddressFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyAddressPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CompanyAddressFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyAddressPayload>
        }
        findMany: {
          args: Prisma.CompanyAddressFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyAddressPayload>[]
        }
        create: {
          args: Prisma.CompanyAddressCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyAddressPayload>
        }
        createMany: {
          args: Prisma.CompanyAddressCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CompanyAddressCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyAddressPayload>[]
        }
        delete: {
          args: Prisma.CompanyAddressDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyAddressPayload>
        }
        update: {
          args: Prisma.CompanyAddressUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyAddressPayload>
        }
        deleteMany: {
          args: Prisma.CompanyAddressDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CompanyAddressUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CompanyAddressUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyAddressPayload>[]
        }
        upsert: {
          args: Prisma.CompanyAddressUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyAddressPayload>
        }
        aggregate: {
          args: Prisma.CompanyAddressAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCompanyAddress>
        }
        groupBy: {
          args: Prisma.CompanyAddressGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompanyAddressGroupByOutputType>[]
        }
        count: {
          args: Prisma.CompanyAddressCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompanyAddressCountAggregateOutputType> | number
        }
      }
    }
    CompanyCnae: {
      payload: Prisma.$CompanyCnaePayload<ExtArgs>
      fields: Prisma.CompanyCnaeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CompanyCnaeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyCnaePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CompanyCnaeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyCnaePayload>
        }
        findFirst: {
          args: Prisma.CompanyCnaeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyCnaePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CompanyCnaeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyCnaePayload>
        }
        findMany: {
          args: Prisma.CompanyCnaeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyCnaePayload>[]
        }
        create: {
          args: Prisma.CompanyCnaeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyCnaePayload>
        }
        createMany: {
          args: Prisma.CompanyCnaeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CompanyCnaeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyCnaePayload>[]
        }
        delete: {
          args: Prisma.CompanyCnaeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyCnaePayload>
        }
        update: {
          args: Prisma.CompanyCnaeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyCnaePayload>
        }
        deleteMany: {
          args: Prisma.CompanyCnaeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CompanyCnaeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CompanyCnaeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyCnaePayload>[]
        }
        upsert: {
          args: Prisma.CompanyCnaeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyCnaePayload>
        }
        aggregate: {
          args: Prisma.CompanyCnaeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCompanyCnae>
        }
        groupBy: {
          args: Prisma.CompanyCnaeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompanyCnaeGroupByOutputType>[]
        }
        count: {
          args: Prisma.CompanyCnaeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompanyCnaeCountAggregateOutputType> | number
        }
      }
    }
    CompanyFiscalSettings: {
      payload: Prisma.$CompanyFiscalSettingsPayload<ExtArgs>
      fields: Prisma.CompanyFiscalSettingsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CompanyFiscalSettingsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyFiscalSettingsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CompanyFiscalSettingsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyFiscalSettingsPayload>
        }
        findFirst: {
          args: Prisma.CompanyFiscalSettingsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyFiscalSettingsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CompanyFiscalSettingsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyFiscalSettingsPayload>
        }
        findMany: {
          args: Prisma.CompanyFiscalSettingsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyFiscalSettingsPayload>[]
        }
        create: {
          args: Prisma.CompanyFiscalSettingsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyFiscalSettingsPayload>
        }
        createMany: {
          args: Prisma.CompanyFiscalSettingsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CompanyFiscalSettingsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyFiscalSettingsPayload>[]
        }
        delete: {
          args: Prisma.CompanyFiscalSettingsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyFiscalSettingsPayload>
        }
        update: {
          args: Prisma.CompanyFiscalSettingsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyFiscalSettingsPayload>
        }
        deleteMany: {
          args: Prisma.CompanyFiscalSettingsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CompanyFiscalSettingsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CompanyFiscalSettingsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyFiscalSettingsPayload>[]
        }
        upsert: {
          args: Prisma.CompanyFiscalSettingsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyFiscalSettingsPayload>
        }
        aggregate: {
          args: Prisma.CompanyFiscalSettingsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCompanyFiscalSettings>
        }
        groupBy: {
          args: Prisma.CompanyFiscalSettingsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompanyFiscalSettingsGroupByOutputType>[]
        }
        count: {
          args: Prisma.CompanyFiscalSettingsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompanyFiscalSettingsCountAggregateOutputType> | number
        }
      }
    }
    CompanyStakeholder: {
      payload: Prisma.$CompanyStakeholderPayload<ExtArgs>
      fields: Prisma.CompanyStakeholderFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CompanyStakeholderFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyStakeholderPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CompanyStakeholderFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyStakeholderPayload>
        }
        findFirst: {
          args: Prisma.CompanyStakeholderFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyStakeholderPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CompanyStakeholderFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyStakeholderPayload>
        }
        findMany: {
          args: Prisma.CompanyStakeholderFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyStakeholderPayload>[]
        }
        create: {
          args: Prisma.CompanyStakeholderCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyStakeholderPayload>
        }
        createMany: {
          args: Prisma.CompanyStakeholderCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CompanyStakeholderCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyStakeholderPayload>[]
        }
        delete: {
          args: Prisma.CompanyStakeholderDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyStakeholderPayload>
        }
        update: {
          args: Prisma.CompanyStakeholderUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyStakeholderPayload>
        }
        deleteMany: {
          args: Prisma.CompanyStakeholderDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CompanyStakeholderUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CompanyStakeholderUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyStakeholderPayload>[]
        }
        upsert: {
          args: Prisma.CompanyStakeholderUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyStakeholderPayload>
        }
        aggregate: {
          args: Prisma.CompanyStakeholderAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCompanyStakeholder>
        }
        groupBy: {
          args: Prisma.CompanyStakeholderGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompanyStakeholderGroupByOutputType>[]
        }
        count: {
          args: Prisma.CompanyStakeholderCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompanyStakeholderCountAggregateOutputType> | number
        }
      }
    }
    LabelTemplate: {
      payload: Prisma.$LabelTemplatePayload<ExtArgs>
      fields: Prisma.LabelTemplateFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LabelTemplateFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LabelTemplatePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LabelTemplateFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LabelTemplatePayload>
        }
        findFirst: {
          args: Prisma.LabelTemplateFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LabelTemplatePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LabelTemplateFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LabelTemplatePayload>
        }
        findMany: {
          args: Prisma.LabelTemplateFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LabelTemplatePayload>[]
        }
        create: {
          args: Prisma.LabelTemplateCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LabelTemplatePayload>
        }
        createMany: {
          args: Prisma.LabelTemplateCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LabelTemplateCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LabelTemplatePayload>[]
        }
        delete: {
          args: Prisma.LabelTemplateDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LabelTemplatePayload>
        }
        update: {
          args: Prisma.LabelTemplateUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LabelTemplatePayload>
        }
        deleteMany: {
          args: Prisma.LabelTemplateDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LabelTemplateUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LabelTemplateUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LabelTemplatePayload>[]
        }
        upsert: {
          args: Prisma.LabelTemplateUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LabelTemplatePayload>
        }
        aggregate: {
          args: Prisma.LabelTemplateAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLabelTemplate>
        }
        groupBy: {
          args: Prisma.LabelTemplateGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LabelTemplateGroupByOutputType>[]
        }
        count: {
          args: Prisma.LabelTemplateCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LabelTemplateCountAggregateOutputType> | number
        }
      }
    }
    Tenant: {
      payload: Prisma.$TenantPayload<ExtArgs>
      fields: Prisma.TenantFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenantFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        findFirst: {
          args: Prisma.TenantFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        findMany: {
          args: Prisma.TenantFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>[]
        }
        create: {
          args: Prisma.TenantCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        createMany: {
          args: Prisma.TenantCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>[]
        }
        delete: {
          args: Prisma.TenantDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        update: {
          args: Prisma.TenantUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        deleteMany: {
          args: Prisma.TenantDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenantUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenantUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>[]
        }
        upsert: {
          args: Prisma.TenantUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        aggregate: {
          args: Prisma.TenantAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenant>
        }
        groupBy: {
          args: Prisma.TenantGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenantCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantCountAggregateOutputType> | number
        }
      }
    }
    Plan: {
      payload: Prisma.$PlanPayload<ExtArgs>
      fields: Prisma.PlanFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PlanFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PlanFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanPayload>
        }
        findFirst: {
          args: Prisma.PlanFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PlanFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanPayload>
        }
        findMany: {
          args: Prisma.PlanFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanPayload>[]
        }
        create: {
          args: Prisma.PlanCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanPayload>
        }
        createMany: {
          args: Prisma.PlanCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PlanCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanPayload>[]
        }
        delete: {
          args: Prisma.PlanDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanPayload>
        }
        update: {
          args: Prisma.PlanUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanPayload>
        }
        deleteMany: {
          args: Prisma.PlanDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PlanUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PlanUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanPayload>[]
        }
        upsert: {
          args: Prisma.PlanUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanPayload>
        }
        aggregate: {
          args: Prisma.PlanAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePlan>
        }
        groupBy: {
          args: Prisma.PlanGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PlanGroupByOutputType>[]
        }
        count: {
          args: Prisma.PlanCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PlanCountAggregateOutputType> | number
        }
      }
    }
    PlanModule: {
      payload: Prisma.$PlanModulePayload<ExtArgs>
      fields: Prisma.PlanModuleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PlanModuleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanModulePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PlanModuleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanModulePayload>
        }
        findFirst: {
          args: Prisma.PlanModuleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanModulePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PlanModuleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanModulePayload>
        }
        findMany: {
          args: Prisma.PlanModuleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanModulePayload>[]
        }
        create: {
          args: Prisma.PlanModuleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanModulePayload>
        }
        createMany: {
          args: Prisma.PlanModuleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PlanModuleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanModulePayload>[]
        }
        delete: {
          args: Prisma.PlanModuleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanModulePayload>
        }
        update: {
          args: Prisma.PlanModuleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanModulePayload>
        }
        deleteMany: {
          args: Prisma.PlanModuleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PlanModuleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PlanModuleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanModulePayload>[]
        }
        upsert: {
          args: Prisma.PlanModuleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanModulePayload>
        }
        aggregate: {
          args: Prisma.PlanModuleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePlanModule>
        }
        groupBy: {
          args: Prisma.PlanModuleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PlanModuleGroupByOutputType>[]
        }
        count: {
          args: Prisma.PlanModuleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PlanModuleCountAggregateOutputType> | number
        }
      }
    }
    TenantPlan: {
      payload: Prisma.$TenantPlanPayload<ExtArgs>
      fields: Prisma.TenantPlanFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenantPlanFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPlanPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenantPlanFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPlanPayload>
        }
        findFirst: {
          args: Prisma.TenantPlanFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPlanPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenantPlanFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPlanPayload>
        }
        findMany: {
          args: Prisma.TenantPlanFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPlanPayload>[]
        }
        create: {
          args: Prisma.TenantPlanCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPlanPayload>
        }
        createMany: {
          args: Prisma.TenantPlanCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenantPlanCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPlanPayload>[]
        }
        delete: {
          args: Prisma.TenantPlanDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPlanPayload>
        }
        update: {
          args: Prisma.TenantPlanUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPlanPayload>
        }
        deleteMany: {
          args: Prisma.TenantPlanDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenantPlanUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenantPlanUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPlanPayload>[]
        }
        upsert: {
          args: Prisma.TenantPlanUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPlanPayload>
        }
        aggregate: {
          args: Prisma.TenantPlanAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenantPlan>
        }
        groupBy: {
          args: Prisma.TenantPlanGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantPlanGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenantPlanCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantPlanCountAggregateOutputType> | number
        }
      }
    }
    TenantUser: {
      payload: Prisma.$TenantUserPayload<ExtArgs>
      fields: Prisma.TenantUserFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenantUserFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantUserPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenantUserFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantUserPayload>
        }
        findFirst: {
          args: Prisma.TenantUserFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantUserPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenantUserFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantUserPayload>
        }
        findMany: {
          args: Prisma.TenantUserFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantUserPayload>[]
        }
        create: {
          args: Prisma.TenantUserCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantUserPayload>
        }
        createMany: {
          args: Prisma.TenantUserCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenantUserCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantUserPayload>[]
        }
        delete: {
          args: Prisma.TenantUserDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantUserPayload>
        }
        update: {
          args: Prisma.TenantUserUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantUserPayload>
        }
        deleteMany: {
          args: Prisma.TenantUserDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenantUserUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenantUserUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantUserPayload>[]
        }
        upsert: {
          args: Prisma.TenantUserUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantUserPayload>
        }
        aggregate: {
          args: Prisma.TenantUserAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenantUser>
        }
        groupBy: {
          args: Prisma.TenantUserGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantUserGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenantUserCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantUserCountAggregateOutputType> | number
        }
      }
    }
    TenantFeatureFlag: {
      payload: Prisma.$TenantFeatureFlagPayload<ExtArgs>
      fields: Prisma.TenantFeatureFlagFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenantFeatureFlagFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantFeatureFlagPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenantFeatureFlagFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantFeatureFlagPayload>
        }
        findFirst: {
          args: Prisma.TenantFeatureFlagFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantFeatureFlagPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenantFeatureFlagFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantFeatureFlagPayload>
        }
        findMany: {
          args: Prisma.TenantFeatureFlagFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantFeatureFlagPayload>[]
        }
        create: {
          args: Prisma.TenantFeatureFlagCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantFeatureFlagPayload>
        }
        createMany: {
          args: Prisma.TenantFeatureFlagCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenantFeatureFlagCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantFeatureFlagPayload>[]
        }
        delete: {
          args: Prisma.TenantFeatureFlagDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantFeatureFlagPayload>
        }
        update: {
          args: Prisma.TenantFeatureFlagUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantFeatureFlagPayload>
        }
        deleteMany: {
          args: Prisma.TenantFeatureFlagDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenantFeatureFlagUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenantFeatureFlagUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantFeatureFlagPayload>[]
        }
        upsert: {
          args: Prisma.TenantFeatureFlagUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantFeatureFlagPayload>
        }
        aggregate: {
          args: Prisma.TenantFeatureFlagAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenantFeatureFlag>
        }
        groupBy: {
          args: Prisma.TenantFeatureFlagGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantFeatureFlagGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenantFeatureFlagCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantFeatureFlagCountAggregateOutputType> | number
        }
      }
    }
    CostCenter: {
      payload: Prisma.$CostCenterPayload<ExtArgs>
      fields: Prisma.CostCenterFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CostCenterFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCenterPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CostCenterFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCenterPayload>
        }
        findFirst: {
          args: Prisma.CostCenterFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCenterPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CostCenterFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCenterPayload>
        }
        findMany: {
          args: Prisma.CostCenterFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCenterPayload>[]
        }
        create: {
          args: Prisma.CostCenterCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCenterPayload>
        }
        createMany: {
          args: Prisma.CostCenterCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CostCenterCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCenterPayload>[]
        }
        delete: {
          args: Prisma.CostCenterDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCenterPayload>
        }
        update: {
          args: Prisma.CostCenterUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCenterPayload>
        }
        deleteMany: {
          args: Prisma.CostCenterDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CostCenterUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CostCenterUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCenterPayload>[]
        }
        upsert: {
          args: Prisma.CostCenterUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCenterPayload>
        }
        aggregate: {
          args: Prisma.CostCenterAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCostCenter>
        }
        groupBy: {
          args: Prisma.CostCenterGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CostCenterGroupByOutputType>[]
        }
        count: {
          args: Prisma.CostCenterCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CostCenterCountAggregateOutputType> | number
        }
      }
    }
    BankAccount: {
      payload: Prisma.$BankAccountPayload<ExtArgs>
      fields: Prisma.BankAccountFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BankAccountFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankAccountPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BankAccountFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankAccountPayload>
        }
        findFirst: {
          args: Prisma.BankAccountFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankAccountPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BankAccountFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankAccountPayload>
        }
        findMany: {
          args: Prisma.BankAccountFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankAccountPayload>[]
        }
        create: {
          args: Prisma.BankAccountCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankAccountPayload>
        }
        createMany: {
          args: Prisma.BankAccountCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.BankAccountCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankAccountPayload>[]
        }
        delete: {
          args: Prisma.BankAccountDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankAccountPayload>
        }
        update: {
          args: Prisma.BankAccountUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankAccountPayload>
        }
        deleteMany: {
          args: Prisma.BankAccountDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BankAccountUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.BankAccountUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankAccountPayload>[]
        }
        upsert: {
          args: Prisma.BankAccountUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankAccountPayload>
        }
        aggregate: {
          args: Prisma.BankAccountAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBankAccount>
        }
        groupBy: {
          args: Prisma.BankAccountGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BankAccountGroupByOutputType>[]
        }
        count: {
          args: Prisma.BankAccountCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BankAccountCountAggregateOutputType> | number
        }
      }
    }
    FinanceCategory: {
      payload: Prisma.$FinanceCategoryPayload<ExtArgs>
      fields: Prisma.FinanceCategoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FinanceCategoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceCategoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FinanceCategoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceCategoryPayload>
        }
        findFirst: {
          args: Prisma.FinanceCategoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceCategoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FinanceCategoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceCategoryPayload>
        }
        findMany: {
          args: Prisma.FinanceCategoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceCategoryPayload>[]
        }
        create: {
          args: Prisma.FinanceCategoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceCategoryPayload>
        }
        createMany: {
          args: Prisma.FinanceCategoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FinanceCategoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceCategoryPayload>[]
        }
        delete: {
          args: Prisma.FinanceCategoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceCategoryPayload>
        }
        update: {
          args: Prisma.FinanceCategoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceCategoryPayload>
        }
        deleteMany: {
          args: Prisma.FinanceCategoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FinanceCategoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FinanceCategoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceCategoryPayload>[]
        }
        upsert: {
          args: Prisma.FinanceCategoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceCategoryPayload>
        }
        aggregate: {
          args: Prisma.FinanceCategoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFinanceCategory>
        }
        groupBy: {
          args: Prisma.FinanceCategoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FinanceCategoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.FinanceCategoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FinanceCategoryCountAggregateOutputType> | number
        }
      }
    }
    FinanceEntry: {
      payload: Prisma.$FinanceEntryPayload<ExtArgs>
      fields: Prisma.FinanceEntryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FinanceEntryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceEntryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FinanceEntryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceEntryPayload>
        }
        findFirst: {
          args: Prisma.FinanceEntryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceEntryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FinanceEntryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceEntryPayload>
        }
        findMany: {
          args: Prisma.FinanceEntryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceEntryPayload>[]
        }
        create: {
          args: Prisma.FinanceEntryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceEntryPayload>
        }
        createMany: {
          args: Prisma.FinanceEntryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FinanceEntryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceEntryPayload>[]
        }
        delete: {
          args: Prisma.FinanceEntryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceEntryPayload>
        }
        update: {
          args: Prisma.FinanceEntryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceEntryPayload>
        }
        deleteMany: {
          args: Prisma.FinanceEntryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FinanceEntryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FinanceEntryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceEntryPayload>[]
        }
        upsert: {
          args: Prisma.FinanceEntryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceEntryPayload>
        }
        aggregate: {
          args: Prisma.FinanceEntryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFinanceEntry>
        }
        groupBy: {
          args: Prisma.FinanceEntryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FinanceEntryGroupByOutputType>[]
        }
        count: {
          args: Prisma.FinanceEntryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FinanceEntryCountAggregateOutputType> | number
        }
      }
    }
    FinanceEntryPayment: {
      payload: Prisma.$FinanceEntryPaymentPayload<ExtArgs>
      fields: Prisma.FinanceEntryPaymentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FinanceEntryPaymentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceEntryPaymentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FinanceEntryPaymentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceEntryPaymentPayload>
        }
        findFirst: {
          args: Prisma.FinanceEntryPaymentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceEntryPaymentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FinanceEntryPaymentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceEntryPaymentPayload>
        }
        findMany: {
          args: Prisma.FinanceEntryPaymentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceEntryPaymentPayload>[]
        }
        create: {
          args: Prisma.FinanceEntryPaymentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceEntryPaymentPayload>
        }
        createMany: {
          args: Prisma.FinanceEntryPaymentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FinanceEntryPaymentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceEntryPaymentPayload>[]
        }
        delete: {
          args: Prisma.FinanceEntryPaymentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceEntryPaymentPayload>
        }
        update: {
          args: Prisma.FinanceEntryPaymentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceEntryPaymentPayload>
        }
        deleteMany: {
          args: Prisma.FinanceEntryPaymentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FinanceEntryPaymentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FinanceEntryPaymentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceEntryPaymentPayload>[]
        }
        upsert: {
          args: Prisma.FinanceEntryPaymentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceEntryPaymentPayload>
        }
        aggregate: {
          args: Prisma.FinanceEntryPaymentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFinanceEntryPayment>
        }
        groupBy: {
          args: Prisma.FinanceEntryPaymentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FinanceEntryPaymentGroupByOutputType>[]
        }
        count: {
          args: Prisma.FinanceEntryPaymentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FinanceEntryPaymentCountAggregateOutputType> | number
        }
      }
    }
    FinanceAttachment: {
      payload: Prisma.$FinanceAttachmentPayload<ExtArgs>
      fields: Prisma.FinanceAttachmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FinanceAttachmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceAttachmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FinanceAttachmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceAttachmentPayload>
        }
        findFirst: {
          args: Prisma.FinanceAttachmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceAttachmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FinanceAttachmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceAttachmentPayload>
        }
        findMany: {
          args: Prisma.FinanceAttachmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceAttachmentPayload>[]
        }
        create: {
          args: Prisma.FinanceAttachmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceAttachmentPayload>
        }
        createMany: {
          args: Prisma.FinanceAttachmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FinanceAttachmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceAttachmentPayload>[]
        }
        delete: {
          args: Prisma.FinanceAttachmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceAttachmentPayload>
        }
        update: {
          args: Prisma.FinanceAttachmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceAttachmentPayload>
        }
        deleteMany: {
          args: Prisma.FinanceAttachmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FinanceAttachmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FinanceAttachmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceAttachmentPayload>[]
        }
        upsert: {
          args: Prisma.FinanceAttachmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceAttachmentPayload>
        }
        aggregate: {
          args: Prisma.FinanceAttachmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFinanceAttachment>
        }
        groupBy: {
          args: Prisma.FinanceAttachmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FinanceAttachmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.FinanceAttachmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FinanceAttachmentCountAggregateOutputType> | number
        }
      }
    }
    Loan: {
      payload: Prisma.$LoanPayload<ExtArgs>
      fields: Prisma.LoanFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LoanFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LoanPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LoanFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LoanPayload>
        }
        findFirst: {
          args: Prisma.LoanFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LoanPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LoanFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LoanPayload>
        }
        findMany: {
          args: Prisma.LoanFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LoanPayload>[]
        }
        create: {
          args: Prisma.LoanCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LoanPayload>
        }
        createMany: {
          args: Prisma.LoanCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LoanCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LoanPayload>[]
        }
        delete: {
          args: Prisma.LoanDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LoanPayload>
        }
        update: {
          args: Prisma.LoanUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LoanPayload>
        }
        deleteMany: {
          args: Prisma.LoanDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LoanUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LoanUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LoanPayload>[]
        }
        upsert: {
          args: Prisma.LoanUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LoanPayload>
        }
        aggregate: {
          args: Prisma.LoanAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLoan>
        }
        groupBy: {
          args: Prisma.LoanGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LoanGroupByOutputType>[]
        }
        count: {
          args: Prisma.LoanCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LoanCountAggregateOutputType> | number
        }
      }
    }
    LoanInstallment: {
      payload: Prisma.$LoanInstallmentPayload<ExtArgs>
      fields: Prisma.LoanInstallmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LoanInstallmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LoanInstallmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LoanInstallmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LoanInstallmentPayload>
        }
        findFirst: {
          args: Prisma.LoanInstallmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LoanInstallmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LoanInstallmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LoanInstallmentPayload>
        }
        findMany: {
          args: Prisma.LoanInstallmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LoanInstallmentPayload>[]
        }
        create: {
          args: Prisma.LoanInstallmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LoanInstallmentPayload>
        }
        createMany: {
          args: Prisma.LoanInstallmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LoanInstallmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LoanInstallmentPayload>[]
        }
        delete: {
          args: Prisma.LoanInstallmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LoanInstallmentPayload>
        }
        update: {
          args: Prisma.LoanInstallmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LoanInstallmentPayload>
        }
        deleteMany: {
          args: Prisma.LoanInstallmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LoanInstallmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LoanInstallmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LoanInstallmentPayload>[]
        }
        upsert: {
          args: Prisma.LoanInstallmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LoanInstallmentPayload>
        }
        aggregate: {
          args: Prisma.LoanInstallmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLoanInstallment>
        }
        groupBy: {
          args: Prisma.LoanInstallmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LoanInstallmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.LoanInstallmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LoanInstallmentCountAggregateOutputType> | number
        }
      }
    }
    Consortium: {
      payload: Prisma.$ConsortiumPayload<ExtArgs>
      fields: Prisma.ConsortiumFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ConsortiumFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsortiumPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ConsortiumFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsortiumPayload>
        }
        findFirst: {
          args: Prisma.ConsortiumFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsortiumPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ConsortiumFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsortiumPayload>
        }
        findMany: {
          args: Prisma.ConsortiumFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsortiumPayload>[]
        }
        create: {
          args: Prisma.ConsortiumCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsortiumPayload>
        }
        createMany: {
          args: Prisma.ConsortiumCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ConsortiumCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsortiumPayload>[]
        }
        delete: {
          args: Prisma.ConsortiumDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsortiumPayload>
        }
        update: {
          args: Prisma.ConsortiumUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsortiumPayload>
        }
        deleteMany: {
          args: Prisma.ConsortiumDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ConsortiumUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ConsortiumUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsortiumPayload>[]
        }
        upsert: {
          args: Prisma.ConsortiumUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsortiumPayload>
        }
        aggregate: {
          args: Prisma.ConsortiumAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConsortium>
        }
        groupBy: {
          args: Prisma.ConsortiumGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConsortiumGroupByOutputType>[]
        }
        count: {
          args: Prisma.ConsortiumCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConsortiumCountAggregateOutputType> | number
        }
      }
    }
    ConsortiumPayment: {
      payload: Prisma.$ConsortiumPaymentPayload<ExtArgs>
      fields: Prisma.ConsortiumPaymentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ConsortiumPaymentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsortiumPaymentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ConsortiumPaymentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsortiumPaymentPayload>
        }
        findFirst: {
          args: Prisma.ConsortiumPaymentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsortiumPaymentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ConsortiumPaymentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsortiumPaymentPayload>
        }
        findMany: {
          args: Prisma.ConsortiumPaymentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsortiumPaymentPayload>[]
        }
        create: {
          args: Prisma.ConsortiumPaymentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsortiumPaymentPayload>
        }
        createMany: {
          args: Prisma.ConsortiumPaymentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ConsortiumPaymentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsortiumPaymentPayload>[]
        }
        delete: {
          args: Prisma.ConsortiumPaymentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsortiumPaymentPayload>
        }
        update: {
          args: Prisma.ConsortiumPaymentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsortiumPaymentPayload>
        }
        deleteMany: {
          args: Prisma.ConsortiumPaymentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ConsortiumPaymentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ConsortiumPaymentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsortiumPaymentPayload>[]
        }
        upsert: {
          args: Prisma.ConsortiumPaymentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsortiumPaymentPayload>
        }
        aggregate: {
          args: Prisma.ConsortiumPaymentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConsortiumPayment>
        }
        groupBy: {
          args: Prisma.ConsortiumPaymentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConsortiumPaymentGroupByOutputType>[]
        }
        count: {
          args: Prisma.ConsortiumPaymentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConsortiumPaymentCountAggregateOutputType> | number
        }
      }
    }
  }
} & {
  other: {
    payload: any
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
    }
  }
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const UserScalarFieldEnum = {
  id: 'id',
  username: 'username',
  email: 'email',
  password_hash: 'password_hash',
  lastLoginIp: 'lastLoginIp',
  failedLoginAttempts: 'failedLoginAttempts',
  blockedUntil: 'blockedUntil',
  passwordResetToken: 'passwordResetToken',
  passwordResetExpires: 'passwordResetExpires',
  forcePasswordReset: 'forcePasswordReset',
  forcePasswordResetReason: 'forcePasswordResetReason',
  forcePasswordResetRequestedBy: 'forcePasswordResetRequestedBy',
  forcePasswordResetRequestedAt: 'forcePasswordResetRequestedAt',
  accessPinHash: 'accessPinHash',
  actionPinHash: 'actionPinHash',
  forceAccessPinSetup: 'forceAccessPinSetup',
  forceActionPinSetup: 'forceActionPinSetup',
  isSuperAdmin: 'isSuperAdmin',
  deletedAt: 'deletedAt',
  lastLoginAt: 'lastLoginAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


export const UserProfileScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  name: 'name',
  surname: 'surname',
  birthday: 'birthday',
  location: 'location',
  bio: 'bio',
  avatarUrl: 'avatarUrl',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type UserProfileScalarFieldEnum = (typeof UserProfileScalarFieldEnum)[keyof typeof UserProfileScalarFieldEnum]


export const SessionScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  tenantId: 'tenantId',
  ip: 'ip',
  createdAt: 'createdAt',
  expiredAt: 'expiredAt',
  revokedAt: 'revokedAt',
  lastUsedAt: 'lastUsedAt',
  userAgent: 'userAgent',
  deviceType: 'deviceType',
  deviceName: 'deviceName',
  browserName: 'browserName',
  browserVersion: 'browserVersion',
  osName: 'osName',
  osVersion: 'osVersion',
  country: 'country',
  countryCode: 'countryCode',
  region: 'region',
  city: 'city',
  timezone: 'timezone',
  latitude: 'latitude',
  longitude: 'longitude',
  isTrusted: 'isTrusted',
  trustVerifiedAt: 'trustVerifiedAt',
  loginMethod: 'loginMethod'
} as const

export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


export const RefreshTokenScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  sessionId: 'sessionId',
  tenantId: 'tenantId',
  token: 'token',
  expiresAt: 'expiresAt',
  createdAt: 'createdAt',
  revokedAt: 'revokedAt'
} as const

export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


export const PermissionScalarFieldEnum = {
  id: 'id',
  code: 'code',
  name: 'name',
  description: 'description',
  module: 'module',
  resource: 'resource',
  action: 'action',
  isSystem: 'isSystem',
  metadata: 'metadata',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


export const PermissionGroupScalarFieldEnum = {
  id: 'id',
  name: 'name',
  slug: 'slug',
  description: 'description',
  isSystem: 'isSystem',
  isActive: 'isActive',
  color: 'color',
  priority: 'priority',
  parentId: 'parentId',
  tenantId: 'tenantId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt'
} as const

export type PermissionGroupScalarFieldEnum = (typeof PermissionGroupScalarFieldEnum)[keyof typeof PermissionGroupScalarFieldEnum]


export const PermissionGroupPermissionScalarFieldEnum = {
  id: 'id',
  groupId: 'groupId',
  permissionId: 'permissionId',
  effect: 'effect',
  conditions: 'conditions',
  createdAt: 'createdAt'
} as const

export type PermissionGroupPermissionScalarFieldEnum = (typeof PermissionGroupPermissionScalarFieldEnum)[keyof typeof PermissionGroupPermissionScalarFieldEnum]


export const UserPermissionGroupScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  groupId: 'groupId',
  expiresAt: 'expiresAt',
  grantedBy: 'grantedBy',
  createdAt: 'createdAt'
} as const

export type UserPermissionGroupScalarFieldEnum = (typeof UserPermissionGroupScalarFieldEnum)[keyof typeof UserPermissionGroupScalarFieldEnum]


export const UserDirectPermissionScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  permissionId: 'permissionId',
  effect: 'effect',
  conditions: 'conditions',
  expiresAt: 'expiresAt',
  grantedBy: 'grantedBy',
  createdAt: 'createdAt'
} as const

export type UserDirectPermissionScalarFieldEnum = (typeof UserDirectPermissionScalarFieldEnum)[keyof typeof UserDirectPermissionScalarFieldEnum]


export const PermissionAuditLogScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  permissionCode: 'permissionCode',
  allowed: 'allowed',
  reason: 'reason',
  resource: 'resource',
  resourceId: 'resourceId',
  action: 'action',
  ip: 'ip',
  userAgent: 'userAgent',
  endpoint: 'endpoint',
  createdAt: 'createdAt'
} as const

export type PermissionAuditLogScalarFieldEnum = (typeof PermissionAuditLogScalarFieldEnum)[keyof typeof PermissionAuditLogScalarFieldEnum]


export const OrganizationScalarFieldEnum = {
  id: 'id',
  type: 'type',
  tenantId: 'tenantId',
  legalName: 'legalName',
  cnpj: 'cnpj',
  cpf: 'cpf',
  tradeName: 'tradeName',
  stateRegistration: 'stateRegistration',
  municipalRegistration: 'municipalRegistration',
  legalNature: 'legalNature',
  taxRegime: 'taxRegime',
  taxRegimeDetail: 'taxRegimeDetail',
  activityStartDate: 'activityStartDate',
  status: 'status',
  email: 'email',
  phoneMain: 'phoneMain',
  phoneAlt: 'phoneAlt',
  website: 'website',
  logoUrl: 'logoUrl',
  typeSpecificData: 'typeSpecificData',
  metadata: 'metadata',
  notes: 'notes',
  deletedAt: 'deletedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


export const OrganizationAddressScalarFieldEnum = {
  id: 'id',
  organizationId: 'organizationId',
  type: 'type',
  street: 'street',
  number: 'number',
  complement: 'complement',
  district: 'district',
  city: 'city',
  state: 'state',
  zip: 'zip',
  ibgeCityCode: 'ibgeCityCode',
  countryCode: 'countryCode',
  isPrimary: 'isPrimary',
  metadata: 'metadata',
  pendingIssues: 'pendingIssues',
  deletedAt: 'deletedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type OrganizationAddressScalarFieldEnum = (typeof OrganizationAddressScalarFieldEnum)[keyof typeof OrganizationAddressScalarFieldEnum]


export const OrganizationCnaeScalarFieldEnum = {
  id: 'id',
  organizationId: 'organizationId',
  code: 'code',
  description: 'description',
  isPrimary: 'isPrimary',
  status: 'status',
  metadata: 'metadata',
  pendingIssues: 'pendingIssues',
  deletedAt: 'deletedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type OrganizationCnaeScalarFieldEnum = (typeof OrganizationCnaeScalarFieldEnum)[keyof typeof OrganizationCnaeScalarFieldEnum]


export const OrganizationFiscalSettingsScalarFieldEnum = {
  id: 'id',
  organizationId: 'organizationId',
  nfeEnabled: 'nfeEnabled',
  nfeSeries: 'nfeSeries',
  nfeNumber: 'nfeNumber',
  nfeEnvironment: 'nfeEnvironment',
  nfePassword: 'nfePassword',
  nfeCertificate: 'nfeCertificate',
  nfeCertType: 'nfeCertType',
  defaultIcmsRate: 'defaultIcmsRate',
  defaultIpiRate: 'defaultIpiRate',
  defaultPisRate: 'defaultPisRate',
  defaultCofinsRate: 'defaultCofinsRate',
  metadata: 'metadata',
  pendingIssues: 'pendingIssues',
  deletedAt: 'deletedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type OrganizationFiscalSettingsScalarFieldEnum = (typeof OrganizationFiscalSettingsScalarFieldEnum)[keyof typeof OrganizationFiscalSettingsScalarFieldEnum]


export const OrganizationStakeholderScalarFieldEnum = {
  id: 'id',
  organizationId: 'organizationId',
  name: 'name',
  cpf: 'cpf',
  role: 'role',
  qualification: 'qualification',
  entryDate: 'entryDate',
  exitDate: 'exitDate',
  status: 'status',
  source: 'source',
  metadata: 'metadata',
  pendingIssues: 'pendingIssues',
  deletedAt: 'deletedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type OrganizationStakeholderScalarFieldEnum = (typeof OrganizationStakeholderScalarFieldEnum)[keyof typeof OrganizationStakeholderScalarFieldEnum]


export const SupplierScalarFieldEnum = {
  id: 'id',
  sequentialCode: 'sequentialCode',
  name: 'name',
  cnpj: 'cnpj',
  taxId: 'taxId',
  contact: 'contact',
  email: 'email',
  phone: 'phone',
  website: 'website',
  address: 'address',
  city: 'city',
  state: 'state',
  zipCode: 'zipCode',
  country: 'country',
  paymentTerms: 'paymentTerms',
  rating: 'rating',
  isActive: 'isActive',
  notes: 'notes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt',
  tenantId: 'tenantId'
} as const

export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


export const ManufacturerScalarFieldEnum = {
  id: 'id',
  code: 'code',
  sequentialCode: 'sequentialCode',
  name: 'name',
  legalName: 'legalName',
  cnpj: 'cnpj',
  country: 'country',
  email: 'email',
  phone: 'phone',
  website: 'website',
  address: 'address',
  city: 'city',
  state: 'state',
  zipCode: 'zipCode',
  isActive: 'isActive',
  notes: 'notes',
  rating: 'rating',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt',
  tenantId: 'tenantId'
} as const

export type ManufacturerScalarFieldEnum = (typeof ManufacturerScalarFieldEnum)[keyof typeof ManufacturerScalarFieldEnum]


export const CategoryScalarFieldEnum = {
  id: 'id',
  name: 'name',
  slug: 'slug',
  description: 'description',
  iconUrl: 'iconUrl',
  parentId: 'parentId',
  displayOrder: 'displayOrder',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt',
  tenantId: 'tenantId'
} as const

export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


export const WarehouseScalarFieldEnum = {
  id: 'id',
  code: 'code',
  name: 'name',
  description: 'description',
  address: 'address',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt',
  tenantId: 'tenantId'
} as const

export type WarehouseScalarFieldEnum = (typeof WarehouseScalarFieldEnum)[keyof typeof WarehouseScalarFieldEnum]


export const ZoneScalarFieldEnum = {
  id: 'id',
  warehouseId: 'warehouseId',
  code: 'code',
  name: 'name',
  description: 'description',
  structure: 'structure',
  layout: 'layout',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt',
  tenantId: 'tenantId'
} as const

export type ZoneScalarFieldEnum = (typeof ZoneScalarFieldEnum)[keyof typeof ZoneScalarFieldEnum]


export const BinScalarFieldEnum = {
  id: 'id',
  zoneId: 'zoneId',
  address: 'address',
  aisle: 'aisle',
  shelf: 'shelf',
  position: 'position',
  capacity: 'capacity',
  currentOccupancy: 'currentOccupancy',
  isActive: 'isActive',
  isBlocked: 'isBlocked',
  blockReason: 'blockReason',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt',
  tenantId: 'tenantId'
} as const

export type BinScalarFieldEnum = (typeof BinScalarFieldEnum)[keyof typeof BinScalarFieldEnum]


export const VolumeScalarFieldEnum = {
  id: 'id',
  code: 'code',
  name: 'name',
  status: 'status',
  notes: 'notes',
  destinationRef: 'destinationRef',
  salesOrderId: 'salesOrderId',
  customerId: 'customerId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  closedAt: 'closedAt',
  deliveredAt: 'deliveredAt',
  returnedAt: 'returnedAt',
  deletedAt: 'deletedAt',
  createdBy: 'createdBy',
  closedBy: 'closedBy',
  deliveredBy: 'deliveredBy',
  tenantId: 'tenantId'
} as const

export type VolumeScalarFieldEnum = (typeof VolumeScalarFieldEnum)[keyof typeof VolumeScalarFieldEnum]


export const VolumeItemScalarFieldEnum = {
  id: 'id',
  volumeId: 'volumeId',
  itemId: 'itemId',
  addedAt: 'addedAt',
  addedBy: 'addedBy'
} as const

export type VolumeItemScalarFieldEnum = (typeof VolumeItemScalarFieldEnum)[keyof typeof VolumeItemScalarFieldEnum]


export const TemplateScalarFieldEnum = {
  id: 'id',
  code: 'code',
  sequentialCode: 'sequentialCode',
  name: 'name',
  iconUrl: 'iconUrl',
  unitOfMeasure: 'unitOfMeasure',
  productAttributes: 'productAttributes',
  variantAttributes: 'variantAttributes',
  itemAttributes: 'itemAttributes',
  careLabel: 'careLabel',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt',
  tenantId: 'tenantId'
} as const

export type TemplateScalarFieldEnum = (typeof TemplateScalarFieldEnum)[keyof typeof TemplateScalarFieldEnum]


export const ProductScalarFieldEnum = {
  id: 'id',
  name: 'name',
  slug: 'slug',
  fullCode: 'fullCode',
  sequentialCode: 'sequentialCode',
  description: 'description',
  status: 'status',
  outOfLine: 'outOfLine',
  attributes: 'attributes',
  barcode: 'barcode',
  eanCode: 'eanCode',
  upcCode: 'upcCode',
  qrCode: 'qrCode',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt',
  careInstructionIds: 'careInstructionIds',
  templateId: 'templateId',
  supplierId: 'supplierId',
  manufacturerId: 'manufacturerId',
  organizationId: 'organizationId',
  tenantId: 'tenantId'
} as const

export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


export const VariantScalarFieldEnum = {
  id: 'id',
  sku: 'sku',
  slug: 'slug',
  fullCode: 'fullCode',
  sequentialCode: 'sequentialCode',
  name: 'name',
  price: 'price',
  imageUrl: 'imageUrl',
  attributes: 'attributes',
  isActive: 'isActive',
  costPrice: 'costPrice',
  profitMargin: 'profitMargin',
  barcode: 'barcode',
  eanCode: 'eanCode',
  upcCode: 'upcCode',
  qrCode: 'qrCode',
  colorHex: 'colorHex',
  colorPantone: 'colorPantone',
  minStock: 'minStock',
  maxStock: 'maxStock',
  reorderPoint: 'reorderPoint',
  reorderQuantity: 'reorderQuantity',
  reference: 'reference',
  similars: 'similars',
  outOfLine: 'outOfLine',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt',
  productId: 'productId',
  tenantId: 'tenantId'
} as const

export type VariantScalarFieldEnum = (typeof VariantScalarFieldEnum)[keyof typeof VariantScalarFieldEnum]


export const ItemScalarFieldEnum = {
  id: 'id',
  uniqueCode: 'uniqueCode',
  slug: 'slug',
  fullCode: 'fullCode',
  sequentialCode: 'sequentialCode',
  initialQuantity: 'initialQuantity',
  currentQuantity: 'currentQuantity',
  unitCost: 'unitCost',
  status: 'status',
  entryDate: 'entryDate',
  attributes: 'attributes',
  barcode: 'barcode',
  eanCode: 'eanCode',
  upcCode: 'upcCode',
  qrCode: 'qrCode',
  batchNumber: 'batchNumber',
  manufacturingDate: 'manufacturingDate',
  expiryDate: 'expiryDate',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt',
  variantId: 'variantId',
  binId: 'binId',
  lastKnownAddress: 'lastKnownAddress',
  tenantId: 'tenantId'
} as const

export type ItemScalarFieldEnum = (typeof ItemScalarFieldEnum)[keyof typeof ItemScalarFieldEnum]


export const ItemMovementScalarFieldEnum = {
  id: 'id',
  quantity: 'quantity',
  quantityBefore: 'quantityBefore',
  quantityAfter: 'quantityAfter',
  movementType: 'movementType',
  reasonCode: 'reasonCode',
  destinationRef: 'destinationRef',
  originRef: 'originRef',
  batchNumber: 'batchNumber',
  notes: 'notes',
  createdAt: 'createdAt',
  itemId: 'itemId',
  userId: 'userId',
  approvedBy: 'approvedBy',
  salesOrderId: 'salesOrderId',
  tenantId: 'tenantId'
} as const

export type ItemMovementScalarFieldEnum = (typeof ItemMovementScalarFieldEnum)[keyof typeof ItemMovementScalarFieldEnum]


export const ProductCategoryScalarFieldEnum = {
  id: 'id',
  productId: 'productId',
  categoryId: 'categoryId',
  order: 'order',
  featured: 'featured',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ProductCategoryScalarFieldEnum = (typeof ProductCategoryScalarFieldEnum)[keyof typeof ProductCategoryScalarFieldEnum]


export const VariantPriceHistoryScalarFieldEnum = {
  id: 'id',
  variantId: 'variantId',
  oldPrice: 'oldPrice',
  newPrice: 'newPrice',
  reason: 'reason',
  createdAt: 'createdAt',
  userId: 'userId'
} as const

export type VariantPriceHistoryScalarFieldEnum = (typeof VariantPriceHistoryScalarFieldEnum)[keyof typeof VariantPriceHistoryScalarFieldEnum]


export const AuditLogScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  action: 'action',
  entity: 'entity',
  module: 'module',
  entityId: 'entityId',
  description: 'description',
  oldData: 'oldData',
  newData: 'newData',
  ip: 'ip',
  userAgent: 'userAgent',
  endpoint: 'endpoint',
  method: 'method',
  userId: 'userId',
  affectedUser: 'affectedUser',
  createdAt: 'createdAt',
  expiresAt: 'expiresAt'
} as const

export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


export const TagScalarFieldEnum = {
  id: 'id',
  name: 'name',
  slug: 'slug',
  color: 'color',
  description: 'description',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt',
  tenantId: 'tenantId'
} as const

export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


export const ProductTagScalarFieldEnum = {
  id: 'id',
  productId: 'productId',
  tagId: 'tagId',
  createdAt: 'createdAt'
} as const

export type ProductTagScalarFieldEnum = (typeof ProductTagScalarFieldEnum)[keyof typeof ProductTagScalarFieldEnum]


export const VariantImageScalarFieldEnum = {
  id: 'id',
  variantId: 'variantId',
  url: 'url',
  alt: 'alt',
  order: 'order',
  isPrimary: 'isPrimary',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type VariantImageScalarFieldEnum = (typeof VariantImageScalarFieldEnum)[keyof typeof VariantImageScalarFieldEnum]


export const AlertScalarFieldEnum = {
  id: 'id',
  type: 'type',
  severity: 'severity',
  entityId: 'entityId',
  message: 'message',
  isRead: 'isRead',
  createdAt: 'createdAt',
  readAt: 'readAt',
  userId: 'userId'
} as const

export type AlertScalarFieldEnum = (typeof AlertScalarFieldEnum)[keyof typeof AlertScalarFieldEnum]


export const PurchaseOrderScalarFieldEnum = {
  id: 'id',
  orderNumber: 'orderNumber',
  status: 'status',
  totalCost: 'totalCost',
  expectedDate: 'expectedDate',
  receivedDate: 'receivedDate',
  notes: 'notes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt',
  supplierId: 'supplierId',
  createdBy: 'createdBy',
  tenantId: 'tenantId'
} as const

export type PurchaseOrderScalarFieldEnum = (typeof PurchaseOrderScalarFieldEnum)[keyof typeof PurchaseOrderScalarFieldEnum]


export const PurchaseOrderItemScalarFieldEnum = {
  id: 'id',
  orderId: 'orderId',
  variantId: 'variantId',
  quantity: 'quantity',
  unitCost: 'unitCost',
  totalCost: 'totalCost',
  notes: 'notes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PurchaseOrderItemScalarFieldEnum = (typeof PurchaseOrderItemScalarFieldEnum)[keyof typeof PurchaseOrderItemScalarFieldEnum]


export const UnitConversionScalarFieldEnum = {
  id: 'id',
  variantId: 'variantId',
  fromUnit: 'fromUnit',
  toUnit: 'toUnit',
  factor: 'factor',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type UnitConversionScalarFieldEnum = (typeof UnitConversionScalarFieldEnum)[keyof typeof UnitConversionScalarFieldEnum]


export const StockSnapshotScalarFieldEnum = {
  id: 'id',
  variantId: 'variantId',
  binId: 'binId',
  quantity: 'quantity',
  totalValue: 'totalValue',
  snapshotDate: 'snapshotDate',
  notes: 'notes',
  createdAt: 'createdAt'
} as const

export type StockSnapshotScalarFieldEnum = (typeof StockSnapshotScalarFieldEnum)[keyof typeof StockSnapshotScalarFieldEnum]


export const CustomerScalarFieldEnum = {
  id: 'id',
  name: 'name',
  type: 'type',
  document: 'document',
  email: 'email',
  phone: 'phone',
  address: 'address',
  city: 'city',
  state: 'state',
  zipCode: 'zipCode',
  country: 'country',
  notes: 'notes',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt',
  tenantId: 'tenantId'
} as const

export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


export const SalesOrderScalarFieldEnum = {
  id: 'id',
  orderNumber: 'orderNumber',
  status: 'status',
  totalPrice: 'totalPrice',
  discount: 'discount',
  finalPrice: 'finalPrice',
  notes: 'notes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt',
  customerId: 'customerId',
  createdBy: 'createdBy',
  tenantId: 'tenantId'
} as const

export type SalesOrderScalarFieldEnum = (typeof SalesOrderScalarFieldEnum)[keyof typeof SalesOrderScalarFieldEnum]


export const SalesOrderItemScalarFieldEnum = {
  id: 'id',
  orderId: 'orderId',
  variantId: 'variantId',
  quantity: 'quantity',
  unitPrice: 'unitPrice',
  discount: 'discount',
  totalPrice: 'totalPrice',
  notes: 'notes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SalesOrderItemScalarFieldEnum = (typeof SalesOrderItemScalarFieldEnum)[keyof typeof SalesOrderItemScalarFieldEnum]


export const ItemReservationScalarFieldEnum = {
  id: 'id',
  itemId: 'itemId',
  quantity: 'quantity',
  reason: 'reason',
  reference: 'reference',
  expiresAt: 'expiresAt',
  releasedAt: 'releasedAt',
  createdAt: 'createdAt',
  userId: 'userId'
} as const

export type ItemReservationScalarFieldEnum = (typeof ItemReservationScalarFieldEnum)[keyof typeof ItemReservationScalarFieldEnum]


export const VariantSupplierCodeScalarFieldEnum = {
  id: 'id',
  variantId: 'variantId',
  supplierId: 'supplierId',
  code: 'code',
  isPrimary: 'isPrimary',
  notes: 'notes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type VariantSupplierCodeScalarFieldEnum = (typeof VariantSupplierCodeScalarFieldEnum)[keyof typeof VariantSupplierCodeScalarFieldEnum]


export const VariantPromotionScalarFieldEnum = {
  id: 'id',
  variantId: 'variantId',
  name: 'name',
  discountType: 'discountType',
  discountValue: 'discountValue',
  startDate: 'startDate',
  endDate: 'endDate',
  isActive: 'isActive',
  notes: 'notes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt'
} as const

export type VariantPromotionScalarFieldEnum = (typeof VariantPromotionScalarFieldEnum)[keyof typeof VariantPromotionScalarFieldEnum]


export const CommentScalarFieldEnum = {
  id: 'id',
  entityType: 'entityType',
  entityId: 'entityId',
  content: 'content',
  parentCommentId: 'parentCommentId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt',
  userId: 'userId'
} as const

export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


export const NotificationPreferenceScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  alertType: 'alertType',
  channel: 'channel',
  isEnabled: 'isEnabled',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt'
} as const

export type NotificationPreferenceScalarFieldEnum = (typeof NotificationPreferenceScalarFieldEnum)[keyof typeof NotificationPreferenceScalarFieldEnum]


export const NotificationTemplateScalarFieldEnum = {
  id: 'id',
  code: 'code',
  name: 'name',
  titleTemplate: 'titleTemplate',
  messageTemplate: 'messageTemplate',
  defaultChannel: 'defaultChannel',
  defaultPriority: 'defaultPriority',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt'
} as const

export type NotificationTemplateScalarFieldEnum = (typeof NotificationTemplateScalarFieldEnum)[keyof typeof NotificationTemplateScalarFieldEnum]


export const NotificationScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  title: 'title',
  message: 'message',
  type: 'type',
  priority: 'priority',
  channel: 'channel',
  actionUrl: 'actionUrl',
  actionText: 'actionText',
  entityType: 'entityType',
  entityId: 'entityId',
  isRead: 'isRead',
  isSent: 'isSent',
  scheduledFor: 'scheduledFor',
  readAt: 'readAt',
  sentAt: 'sentAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt'
} as const

export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


export const RequestScalarFieldEnum = {
  id: 'id',
  title: 'title',
  description: 'description',
  type: 'type',
  category: 'category',
  status: 'status',
  priority: 'priority',
  requesterId: 'requesterId',
  targetType: 'targetType',
  targetId: 'targetId',
  assignedToId: 'assignedToId',
  dueDate: 'dueDate',
  slaDeadline: 'slaDeadline',
  metadata: 'metadata',
  requiresApproval: 'requiresApproval',
  approvalId: 'approvalId',
  submittedAt: 'submittedAt',
  completedAt: 'completedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt'
} as const

export type RequestScalarFieldEnum = (typeof RequestScalarFieldEnum)[keyof typeof RequestScalarFieldEnum]


export const RequestAttachmentScalarFieldEnum = {
  id: 'id',
  requestId: 'requestId',
  fileName: 'fileName',
  filePath: 'filePath',
  fileSize: 'fileSize',
  mimeType: 'mimeType',
  uploadedById: 'uploadedById',
  createdAt: 'createdAt'
} as const

export type RequestAttachmentScalarFieldEnum = (typeof RequestAttachmentScalarFieldEnum)[keyof typeof RequestAttachmentScalarFieldEnum]


export const RequestCommentScalarFieldEnum = {
  id: 'id',
  requestId: 'requestId',
  authorId: 'authorId',
  content: 'content',
  isInternal: 'isInternal',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt'
} as const

export type RequestCommentScalarFieldEnum = (typeof RequestCommentScalarFieldEnum)[keyof typeof RequestCommentScalarFieldEnum]


export const RequestHistoryScalarFieldEnum = {
  id: 'id',
  requestId: 'requestId',
  action: 'action',
  description: 'description',
  performedById: 'performedById',
  oldValue: 'oldValue',
  newValue: 'newValue',
  createdAt: 'createdAt'
} as const

export type RequestHistoryScalarFieldEnum = (typeof RequestHistoryScalarFieldEnum)[keyof typeof RequestHistoryScalarFieldEnum]


export const EmployeeScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  registrationNumber: 'registrationNumber',
  userId: 'userId',
  fullName: 'fullName',
  socialName: 'socialName',
  birthDate: 'birthDate',
  gender: 'gender',
  pcd: 'pcd',
  maritalStatus: 'maritalStatus',
  nationality: 'nationality',
  birthPlace: 'birthPlace',
  emergencyContactInfo: 'emergencyContactInfo',
  healthConditions: 'healthConditions',
  cpf: 'cpf',
  rg: 'rg',
  rgIssuer: 'rgIssuer',
  rgIssueDate: 'rgIssueDate',
  pis: 'pis',
  ctpsNumber: 'ctpsNumber',
  ctpsSeries: 'ctpsSeries',
  ctpsState: 'ctpsState',
  voterTitle: 'voterTitle',
  militaryDoc: 'militaryDoc',
  email: 'email',
  personalEmail: 'personalEmail',
  phone: 'phone',
  mobilePhone: 'mobilePhone',
  emergencyContact: 'emergencyContact',
  emergencyPhone: 'emergencyPhone',
  address: 'address',
  addressNumber: 'addressNumber',
  complement: 'complement',
  neighborhood: 'neighborhood',
  city: 'city',
  state: 'state',
  zipCode: 'zipCode',
  country: 'country',
  bankCode: 'bankCode',
  bankName: 'bankName',
  bankAgency: 'bankAgency',
  bankAccount: 'bankAccount',
  bankAccountType: 'bankAccountType',
  pixKey: 'pixKey',
  departmentId: 'departmentId',
  positionId: 'positionId',
  supervisorId: 'supervisorId',
  organizationId: 'organizationId',
  hireDate: 'hireDate',
  terminationDate: 'terminationDate',
  status: 'status',
  baseSalary: 'baseSalary',
  contractType: 'contractType',
  workRegime: 'workRegime',
  weeklyHours: 'weeklyHours',
  photoUrl: 'photoUrl',
  metadata: 'metadata',
  pendingIssues: 'pendingIssues',
  deletedAt: 'deletedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  companyId: 'companyId'
} as const

export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


export const DepartmentScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  name: 'name',
  code: 'code',
  description: 'description',
  parentId: 'parentId',
  managerId: 'managerId',
  companyId: 'companyId',
  isActive: 'isActive',
  deletedAt: 'deletedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


export const PositionScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  name: 'name',
  code: 'code',
  description: 'description',
  departmentId: 'departmentId',
  level: 'level',
  minSalary: 'minSalary',
  maxSalary: 'maxSalary',
  baseSalary: 'baseSalary',
  isActive: 'isActive',
  deletedAt: 'deletedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PositionScalarFieldEnum = (typeof PositionScalarFieldEnum)[keyof typeof PositionScalarFieldEnum]


export const TimeEntryScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  employeeId: 'employeeId',
  entryType: 'entryType',
  timestamp: 'timestamp',
  latitude: 'latitude',
  longitude: 'longitude',
  ipAddress: 'ipAddress',
  notes: 'notes',
  createdAt: 'createdAt'
} as const

export type TimeEntryScalarFieldEnum = (typeof TimeEntryScalarFieldEnum)[keyof typeof TimeEntryScalarFieldEnum]


export const WorkScheduleScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  name: 'name',
  description: 'description',
  mondayStart: 'mondayStart',
  mondayEnd: 'mondayEnd',
  tuesdayStart: 'tuesdayStart',
  tuesdayEnd: 'tuesdayEnd',
  wednesdayStart: 'wednesdayStart',
  wednesdayEnd: 'wednesdayEnd',
  thursdayStart: 'thursdayStart',
  thursdayEnd: 'thursdayEnd',
  fridayStart: 'fridayStart',
  fridayEnd: 'fridayEnd',
  saturdayStart: 'saturdayStart',
  saturdayEnd: 'saturdayEnd',
  sundayStart: 'sundayStart',
  sundayEnd: 'sundayEnd',
  breakDuration: 'breakDuration',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type WorkScheduleScalarFieldEnum = (typeof WorkScheduleScalarFieldEnum)[keyof typeof WorkScheduleScalarFieldEnum]


export const OvertimeScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  employeeId: 'employeeId',
  date: 'date',
  hours: 'hours',
  reason: 'reason',
  approved: 'approved',
  approvedBy: 'approvedBy',
  approvedAt: 'approvedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type OvertimeScalarFieldEnum = (typeof OvertimeScalarFieldEnum)[keyof typeof OvertimeScalarFieldEnum]


export const TimeBankScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  employeeId: 'employeeId',
  balance: 'balance',
  year: 'year',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TimeBankScalarFieldEnum = (typeof TimeBankScalarFieldEnum)[keyof typeof TimeBankScalarFieldEnum]


export const AbsenceScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  employeeId: 'employeeId',
  type: 'type',
  status: 'status',
  userId: 'userId',
  startDate: 'startDate',
  endDate: 'endDate',
  totalDays: 'totalDays',
  reason: 'reason',
  documentUrl: 'documentUrl',
  cid: 'cid',
  isPaid: 'isPaid',
  isInssResponsibility: 'isInssResponsibility',
  vacationPeriodId: 'vacationPeriodId',
  notes: 'notes',
  requestedBy: 'requestedBy',
  approvedBy: 'approvedBy',
  approvedAt: 'approvedAt',
  rejectionReason: 'rejectionReason',
  deletedAt: 'deletedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AbsenceScalarFieldEnum = (typeof AbsenceScalarFieldEnum)[keyof typeof AbsenceScalarFieldEnum]


export const VacationPeriodScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  employeeId: 'employeeId',
  acquisitionStart: 'acquisitionStart',
  acquisitionEnd: 'acquisitionEnd',
  concessionStart: 'concessionStart',
  concessionEnd: 'concessionEnd',
  totalDays: 'totalDays',
  usedDays: 'usedDays',
  soldDays: 'soldDays',
  remainingDays: 'remainingDays',
  status: 'status',
  scheduledStart: 'scheduledStart',
  scheduledEnd: 'scheduledEnd',
  notes: 'notes',
  deletedAt: 'deletedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type VacationPeriodScalarFieldEnum = (typeof VacationPeriodScalarFieldEnum)[keyof typeof VacationPeriodScalarFieldEnum]


export const PayrollScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  referenceMonth: 'referenceMonth',
  referenceYear: 'referenceYear',
  status: 'status',
  totalGross: 'totalGross',
  totalDeductions: 'totalDeductions',
  totalNet: 'totalNet',
  processedAt: 'processedAt',
  processedBy: 'processedBy',
  approvedAt: 'approvedAt',
  approvedBy: 'approvedBy',
  paidAt: 'paidAt',
  paidBy: 'paidBy',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PayrollScalarFieldEnum = (typeof PayrollScalarFieldEnum)[keyof typeof PayrollScalarFieldEnum]


export const PayrollItemScalarFieldEnum = {
  id: 'id',
  payrollId: 'payrollId',
  employeeId: 'employeeId',
  type: 'type',
  description: 'description',
  amount: 'amount',
  isDeduction: 'isDeduction',
  referenceId: 'referenceId',
  referenceType: 'referenceType',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PayrollItemScalarFieldEnum = (typeof PayrollItemScalarFieldEnum)[keyof typeof PayrollItemScalarFieldEnum]


export const BonusScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  employeeId: 'employeeId',
  name: 'name',
  amount: 'amount',
  reason: 'reason',
  date: 'date',
  isPaid: 'isPaid',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type BonusScalarFieldEnum = (typeof BonusScalarFieldEnum)[keyof typeof BonusScalarFieldEnum]


export const DeductionScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  employeeId: 'employeeId',
  name: 'name',
  amount: 'amount',
  reason: 'reason',
  date: 'date',
  isRecurring: 'isRecurring',
  installments: 'installments',
  currentInstallment: 'currentInstallment',
  isApplied: 'isApplied',
  appliedAt: 'appliedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DeductionScalarFieldEnum = (typeof DeductionScalarFieldEnum)[keyof typeof DeductionScalarFieldEnum]


export const CompanyScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  legalName: 'legalName',
  cnpj: 'cnpj',
  tradeName: 'tradeName',
  stateRegistration: 'stateRegistration',
  municipalRegistration: 'municipalRegistration',
  legalNature: 'legalNature',
  taxRegime: 'taxRegime',
  taxRegimeDetail: 'taxRegimeDetail',
  activityStartDate: 'activityStartDate',
  status: 'status',
  email: 'email',
  phoneMain: 'phoneMain',
  phoneAlt: 'phoneAlt',
  logoUrl: 'logoUrl',
  metadata: 'metadata',
  pendingIssues: 'pendingIssues',
  deletedAt: 'deletedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


export const CompanyAddressScalarFieldEnum = {
  id: 'id',
  companyId: 'companyId',
  type: 'type',
  street: 'street',
  number: 'number',
  complement: 'complement',
  district: 'district',
  city: 'city',
  state: 'state',
  zip: 'zip',
  ibgeCityCode: 'ibgeCityCode',
  countryCode: 'countryCode',
  isPrimary: 'isPrimary',
  metadata: 'metadata',
  pendingIssues: 'pendingIssues',
  deletedAt: 'deletedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CompanyAddressScalarFieldEnum = (typeof CompanyAddressScalarFieldEnum)[keyof typeof CompanyAddressScalarFieldEnum]


export const CompanyCnaeScalarFieldEnum = {
  id: 'id',
  companyId: 'companyId',
  code: 'code',
  description: 'description',
  isPrimary: 'isPrimary',
  status: 'status',
  metadata: 'metadata',
  pendingIssues: 'pendingIssues',
  deletedAt: 'deletedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CompanyCnaeScalarFieldEnum = (typeof CompanyCnaeScalarFieldEnum)[keyof typeof CompanyCnaeScalarFieldEnum]


export const CompanyFiscalSettingsScalarFieldEnum = {
  id: 'id',
  companyId: 'companyId',
  nfeEnvironment: 'nfeEnvironment',
  nfeSeries: 'nfeSeries',
  nfeLastNumber: 'nfeLastNumber',
  nfeDefaultOperationNature: 'nfeDefaultOperationNature',
  nfeDefaultCfop: 'nfeDefaultCfop',
  digitalCertificateType: 'digitalCertificateType',
  certificateA1PfxBlob: 'certificateA1PfxBlob',
  certificateA1Password: 'certificateA1Password',
  certificateA1ExpiresAt: 'certificateA1ExpiresAt',
  nfceEnabled: 'nfceEnabled',
  nfceCscId: 'nfceCscId',
  nfceCscToken: 'nfceCscToken',
  defaultTaxProfileId: 'defaultTaxProfileId',
  metadata: 'metadata',
  pendingIssues: 'pendingIssues',
  deletedAt: 'deletedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CompanyFiscalSettingsScalarFieldEnum = (typeof CompanyFiscalSettingsScalarFieldEnum)[keyof typeof CompanyFiscalSettingsScalarFieldEnum]


export const CompanyStakeholderScalarFieldEnum = {
  id: 'id',
  companyId: 'companyId',
  name: 'name',
  role: 'role',
  entryDate: 'entryDate',
  exitDate: 'exitDate',
  personDocumentMasked: 'personDocumentMasked',
  isLegalRepresentative: 'isLegalRepresentative',
  status: 'status',
  source: 'source',
  rawPayloadRef: 'rawPayloadRef',
  metadata: 'metadata',
  pendingIssues: 'pendingIssues',
  anonimizedAt: 'anonimizedAt',
  deletedAt: 'deletedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CompanyStakeholderScalarFieldEnum = (typeof CompanyStakeholderScalarFieldEnum)[keyof typeof CompanyStakeholderScalarFieldEnum]


export const LabelTemplateScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  isSystem: 'isSystem',
  width: 'width',
  height: 'height',
  grapesJsData: 'grapesJsData',
  compiledHtml: 'compiledHtml',
  compiledCss: 'compiledCss',
  thumbnailUrl: 'thumbnailUrl',
  tenantId: 'tenantId',
  createdById: 'createdById',
  deletedAt: 'deletedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type LabelTemplateScalarFieldEnum = (typeof LabelTemplateScalarFieldEnum)[keyof typeof LabelTemplateScalarFieldEnum]


export const TenantScalarFieldEnum = {
  id: 'id',
  name: 'name',
  slug: 'slug',
  logoUrl: 'logoUrl',
  status: 'status',
  settings: 'settings',
  metadata: 'metadata',
  deletedAt: 'deletedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


export const PlanScalarFieldEnum = {
  id: 'id',
  name: 'name',
  tier: 'tier',
  description: 'description',
  price: 'price',
  isActive: 'isActive',
  maxUsers: 'maxUsers',
  maxWarehouses: 'maxWarehouses',
  maxProducts: 'maxProducts',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PlanScalarFieldEnum = (typeof PlanScalarFieldEnum)[keyof typeof PlanScalarFieldEnum]


export const PlanModuleScalarFieldEnum = {
  id: 'id',
  planId: 'planId',
  module: 'module'
} as const

export type PlanModuleScalarFieldEnum = (typeof PlanModuleScalarFieldEnum)[keyof typeof PlanModuleScalarFieldEnum]


export const TenantPlanScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  planId: 'planId',
  startsAt: 'startsAt',
  expiresAt: 'expiresAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TenantPlanScalarFieldEnum = (typeof TenantPlanScalarFieldEnum)[keyof typeof TenantPlanScalarFieldEnum]


export const TenantUserScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  userId: 'userId',
  role: 'role',
  joinedAt: 'joinedAt',
  deletedAt: 'deletedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TenantUserScalarFieldEnum = (typeof TenantUserScalarFieldEnum)[keyof typeof TenantUserScalarFieldEnum]


export const TenantFeatureFlagScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  flag: 'flag',
  enabled: 'enabled',
  metadata: 'metadata',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TenantFeatureFlagScalarFieldEnum = (typeof TenantFeatureFlagScalarFieldEnum)[keyof typeof TenantFeatureFlagScalarFieldEnum]


export const CostCenterScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  companyId: 'companyId',
  code: 'code',
  name: 'name',
  description: 'description',
  isActive: 'isActive',
  monthlyBudget: 'monthlyBudget',
  annualBudget: 'annualBudget',
  parentId: 'parentId',
  deletedAt: 'deletedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CostCenterScalarFieldEnum = (typeof CostCenterScalarFieldEnum)[keyof typeof CostCenterScalarFieldEnum]


export const BankAccountScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  companyId: 'companyId',
  name: 'name',
  bankCode: 'bankCode',
  bankName: 'bankName',
  agency: 'agency',
  agencyDigit: 'agencyDigit',
  accountNumber: 'accountNumber',
  accountDigit: 'accountDigit',
  accountType: 'accountType',
  status: 'status',
  pixKeyType: 'pixKeyType',
  pixKey: 'pixKey',
  currentBalance: 'currentBalance',
  balanceUpdatedAt: 'balanceUpdatedAt',
  color: 'color',
  isDefault: 'isDefault',
  deletedAt: 'deletedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type BankAccountScalarFieldEnum = (typeof BankAccountScalarFieldEnum)[keyof typeof BankAccountScalarFieldEnum]


export const FinanceCategoryScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  name: 'name',
  slug: 'slug',
  description: 'description',
  iconUrl: 'iconUrl',
  color: 'color',
  type: 'type',
  parentId: 'parentId',
  displayOrder: 'displayOrder',
  isActive: 'isActive',
  isSystem: 'isSystem',
  deletedAt: 'deletedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FinanceCategoryScalarFieldEnum = (typeof FinanceCategoryScalarFieldEnum)[keyof typeof FinanceCategoryScalarFieldEnum]


export const FinanceEntryScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  type: 'type',
  code: 'code',
  description: 'description',
  notes: 'notes',
  categoryId: 'categoryId',
  costCenterId: 'costCenterId',
  bankAccountId: 'bankAccountId',
  supplierName: 'supplierName',
  customerName: 'customerName',
  supplierId: 'supplierId',
  customerId: 'customerId',
  salesOrderId: 'salesOrderId',
  expectedAmount: 'expectedAmount',
  actualAmount: 'actualAmount',
  discount: 'discount',
  interest: 'interest',
  penalty: 'penalty',
  issueDate: 'issueDate',
  dueDate: 'dueDate',
  competenceDate: 'competenceDate',
  paymentDate: 'paymentDate',
  status: 'status',
  recurrenceType: 'recurrenceType',
  recurrenceInterval: 'recurrenceInterval',
  recurrenceUnit: 'recurrenceUnit',
  totalInstallments: 'totalInstallments',
  currentInstallment: 'currentInstallment',
  parentEntryId: 'parentEntryId',
  boletoBarcode: 'boletoBarcode',
  boletoDigitLine: 'boletoDigitLine',
  metadata: 'metadata',
  tags: 'tags',
  deletedAt: 'deletedAt',
  createdBy: 'createdBy',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FinanceEntryScalarFieldEnum = (typeof FinanceEntryScalarFieldEnum)[keyof typeof FinanceEntryScalarFieldEnum]


export const FinanceEntryPaymentScalarFieldEnum = {
  id: 'id',
  entryId: 'entryId',
  bankAccountId: 'bankAccountId',
  amount: 'amount',
  paidAt: 'paidAt',
  method: 'method',
  reference: 'reference',
  notes: 'notes',
  createdBy: 'createdBy',
  createdAt: 'createdAt'
} as const

export type FinanceEntryPaymentScalarFieldEnum = (typeof FinanceEntryPaymentScalarFieldEnum)[keyof typeof FinanceEntryPaymentScalarFieldEnum]


export const FinanceAttachmentScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  entryId: 'entryId',
  type: 'type',
  fileName: 'fileName',
  fileKey: 'fileKey',
  fileSize: 'fileSize',
  mimeType: 'mimeType',
  uploadedBy: 'uploadedBy',
  createdAt: 'createdAt'
} as const

export type FinanceAttachmentScalarFieldEnum = (typeof FinanceAttachmentScalarFieldEnum)[keyof typeof FinanceAttachmentScalarFieldEnum]


export const LoanScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  bankAccountId: 'bankAccountId',
  costCenterId: 'costCenterId',
  name: 'name',
  type: 'type',
  contractNumber: 'contractNumber',
  status: 'status',
  principalAmount: 'principalAmount',
  outstandingBalance: 'outstandingBalance',
  interestRate: 'interestRate',
  interestType: 'interestType',
  startDate: 'startDate',
  endDate: 'endDate',
  totalInstallments: 'totalInstallments',
  paidInstallments: 'paidInstallments',
  installmentDay: 'installmentDay',
  notes: 'notes',
  metadata: 'metadata',
  deletedAt: 'deletedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type LoanScalarFieldEnum = (typeof LoanScalarFieldEnum)[keyof typeof LoanScalarFieldEnum]


export const LoanInstallmentScalarFieldEnum = {
  id: 'id',
  loanId: 'loanId',
  bankAccountId: 'bankAccountId',
  installmentNumber: 'installmentNumber',
  dueDate: 'dueDate',
  principalAmount: 'principalAmount',
  interestAmount: 'interestAmount',
  totalAmount: 'totalAmount',
  paidAmount: 'paidAmount',
  paidAt: 'paidAt',
  status: 'status',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type LoanInstallmentScalarFieldEnum = (typeof LoanInstallmentScalarFieldEnum)[keyof typeof LoanInstallmentScalarFieldEnum]


export const ConsortiumScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  bankAccountId: 'bankAccountId',
  costCenterId: 'costCenterId',
  name: 'name',
  administrator: 'administrator',
  groupNumber: 'groupNumber',
  quotaNumber: 'quotaNumber',
  contractNumber: 'contractNumber',
  status: 'status',
  creditValue: 'creditValue',
  monthlyPayment: 'monthlyPayment',
  totalInstallments: 'totalInstallments',
  paidInstallments: 'paidInstallments',
  isContemplated: 'isContemplated',
  contemplatedAt: 'contemplatedAt',
  contemplationType: 'contemplationType',
  startDate: 'startDate',
  endDate: 'endDate',
  paymentDay: 'paymentDay',
  notes: 'notes',
  metadata: 'metadata',
  deletedAt: 'deletedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ConsortiumScalarFieldEnum = (typeof ConsortiumScalarFieldEnum)[keyof typeof ConsortiumScalarFieldEnum]


export const ConsortiumPaymentScalarFieldEnum = {
  id: 'id',
  consortiumId: 'consortiumId',
  bankAccountId: 'bankAccountId',
  installmentNumber: 'installmentNumber',
  dueDate: 'dueDate',
  expectedAmount: 'expectedAmount',
  paidAmount: 'paidAmount',
  paidAt: 'paidAt',
  status: 'status',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ConsortiumPaymentScalarFieldEnum = (typeof ConsortiumPaymentScalarFieldEnum)[keyof typeof ConsortiumPaymentScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const JsonNullValueInput = {
  JsonNull: JsonNull
} as const

export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


export const NullableJsonNullValueInput = {
  DbNull: DbNull,
  JsonNull: JsonNull
} as const

export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


export const QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


export const JsonNullValueFilter = {
  DbNull: DbNull,
  JsonNull: JsonNull,
  AnyNull: AnyNull
} as const

export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]



/**
 * Field references
 */


/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


/**
 * Reference to a field of type 'String[]'
 */
export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


/**
 * Reference to a field of type 'Int[]'
 */
export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


/**
 * Reference to a field of type 'DateTime[]'
 */
export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


/**
 * Reference to a field of type 'Float[]'
 */
export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


/**
 * Reference to a field of type 'Json'
 */
export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


/**
 * Reference to a field of type 'QueryMode'
 */
export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


/**
 * Reference to a field of type 'OrganizationType'
 */
export type EnumOrganizationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrganizationType'>
    


/**
 * Reference to a field of type 'OrganizationType[]'
 */
export type ListEnumOrganizationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrganizationType[]'>
    


/**
 * Reference to a field of type 'TaxRegimeEnum'
 */
export type EnumTaxRegimeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaxRegimeEnum'>
    


/**
 * Reference to a field of type 'TaxRegimeEnum[]'
 */
export type ListEnumTaxRegimeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaxRegimeEnum[]'>
    


/**
 * Reference to a field of type 'OrganizationStatusEnum'
 */
export type EnumOrganizationStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrganizationStatusEnum'>
    


/**
 * Reference to a field of type 'OrganizationStatusEnum[]'
 */
export type ListEnumOrganizationStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrganizationStatusEnum[]'>
    


/**
 * Reference to a field of type 'CompanyAddressType'
 */
export type EnumCompanyAddressTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyAddressType'>
    


/**
 * Reference to a field of type 'CompanyAddressType[]'
 */
export type ListEnumCompanyAddressTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyAddressType[]'>
    


/**
 * Reference to a field of type 'CompanyCnaeStatus'
 */
export type EnumCompanyCnaeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyCnaeStatus'>
    


/**
 * Reference to a field of type 'CompanyCnaeStatus[]'
 */
export type ListEnumCompanyCnaeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyCnaeStatus[]'>
    


/**
 * Reference to a field of type 'NfeEnvironment'
 */
export type EnumNfeEnvironmentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NfeEnvironment'>
    


/**
 * Reference to a field of type 'NfeEnvironment[]'
 */
export type ListEnumNfeEnvironmentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NfeEnvironment[]'>
    


/**
 * Reference to a field of type 'DigitalCertificateType'
 */
export type EnumDigitalCertificateTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DigitalCertificateType'>
    


/**
 * Reference to a field of type 'DigitalCertificateType[]'
 */
export type ListEnumDigitalCertificateTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DigitalCertificateType[]'>
    


/**
 * Reference to a field of type 'Decimal'
 */
export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


/**
 * Reference to a field of type 'Decimal[]'
 */
export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


/**
 * Reference to a field of type 'CompanyStakeholderRole'
 */
export type EnumCompanyStakeholderRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyStakeholderRole'>
    


/**
 * Reference to a field of type 'CompanyStakeholderRole[]'
 */
export type ListEnumCompanyStakeholderRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyStakeholderRole[]'>
    


/**
 * Reference to a field of type 'CompanyStakeholderStatus'
 */
export type EnumCompanyStakeholderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyStakeholderStatus'>
    


/**
 * Reference to a field of type 'CompanyStakeholderStatus[]'
 */
export type ListEnumCompanyStakeholderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyStakeholderStatus[]'>
    


/**
 * Reference to a field of type 'CompanyStakeholderSource'
 */
export type EnumCompanyStakeholderSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyStakeholderSource'>
    


/**
 * Reference to a field of type 'CompanyStakeholderSource[]'
 */
export type ListEnumCompanyStakeholderSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyStakeholderSource[]'>
    


/**
 * Reference to a field of type 'VolumeStatus'
 */
export type EnumVolumeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VolumeStatus'>
    


/**
 * Reference to a field of type 'VolumeStatus[]'
 */
export type ListEnumVolumeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VolumeStatus[]'>
    


/**
 * Reference to a field of type 'UnitOfMeasure'
 */
export type EnumUnitOfMeasureFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UnitOfMeasure'>
    


/**
 * Reference to a field of type 'UnitOfMeasure[]'
 */
export type ListEnumUnitOfMeasureFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UnitOfMeasure[]'>
    


/**
 * Reference to a field of type 'ProductStatus'
 */
export type EnumProductStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductStatus'>
    


/**
 * Reference to a field of type 'ProductStatus[]'
 */
export type ListEnumProductStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductStatus[]'>
    


/**
 * Reference to a field of type 'ItemStatus'
 */
export type EnumItemStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemStatus'>
    


/**
 * Reference to a field of type 'ItemStatus[]'
 */
export type ListEnumItemStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemStatus[]'>
    


/**
 * Reference to a field of type 'MovementType'
 */
export type EnumMovementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MovementType'>
    


/**
 * Reference to a field of type 'MovementType[]'
 */
export type ListEnumMovementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MovementType[]'>
    


/**
 * Reference to a field of type 'AuditAction'
 */
export type EnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction'>
    


/**
 * Reference to a field of type 'AuditAction[]'
 */
export type ListEnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction[]'>
    


/**
 * Reference to a field of type 'AuditEntity'
 */
export type EnumAuditEntityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditEntity'>
    


/**
 * Reference to a field of type 'AuditEntity[]'
 */
export type ListEnumAuditEntityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditEntity[]'>
    


/**
 * Reference to a field of type 'AuditModule'
 */
export type EnumAuditModuleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditModule'>
    


/**
 * Reference to a field of type 'AuditModule[]'
 */
export type ListEnumAuditModuleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditModule[]'>
    


/**
 * Reference to a field of type 'AlertType'
 */
export type EnumAlertTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertType'>
    


/**
 * Reference to a field of type 'AlertType[]'
 */
export type ListEnumAlertTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertType[]'>
    


/**
 * Reference to a field of type 'AlertSeverity'
 */
export type EnumAlertSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertSeverity'>
    


/**
 * Reference to a field of type 'AlertSeverity[]'
 */
export type ListEnumAlertSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertSeverity[]'>
    


/**
 * Reference to a field of type 'OrderStatus'
 */
export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


/**
 * Reference to a field of type 'OrderStatus[]'
 */
export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    


/**
 * Reference to a field of type 'CustomerType'
 */
export type EnumCustomerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CustomerType'>
    


/**
 * Reference to a field of type 'CustomerType[]'
 */
export type ListEnumCustomerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CustomerType[]'>
    


/**
 * Reference to a field of type 'DiscountType'
 */
export type EnumDiscountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountType'>
    


/**
 * Reference to a field of type 'DiscountType[]'
 */
export type ListEnumDiscountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountType[]'>
    


/**
 * Reference to a field of type 'NotificationChannel'
 */
export type EnumNotificationChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationChannel'>
    


/**
 * Reference to a field of type 'NotificationChannel[]'
 */
export type ListEnumNotificationChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationChannel[]'>
    


/**
 * Reference to a field of type 'NotificationPriority'
 */
export type EnumNotificationPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationPriority'>
    


/**
 * Reference to a field of type 'NotificationPriority[]'
 */
export type ListEnumNotificationPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationPriority[]'>
    


/**
 * Reference to a field of type 'NotificationType'
 */
export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


/**
 * Reference to a field of type 'NotificationType[]'
 */
export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


/**
 * Reference to a field of type 'RequestType'
 */
export type EnumRequestTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestType'>
    


/**
 * Reference to a field of type 'RequestType[]'
 */
export type ListEnumRequestTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestType[]'>
    


/**
 * Reference to a field of type 'RequestStatus'
 */
export type EnumRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestStatus'>
    


/**
 * Reference to a field of type 'RequestStatus[]'
 */
export type ListEnumRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestStatus[]'>
    


/**
 * Reference to a field of type 'RequestPriority'
 */
export type EnumRequestPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestPriority'>
    


/**
 * Reference to a field of type 'RequestPriority[]'
 */
export type ListEnumRequestPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestPriority[]'>
    


/**
 * Reference to a field of type 'RequestTargetType'
 */
export type EnumRequestTargetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestTargetType'>
    


/**
 * Reference to a field of type 'RequestTargetType[]'
 */
export type ListEnumRequestTargetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestTargetType[]'>
    


/**
 * Reference to a field of type 'EmployeeStatus'
 */
export type EnumEmployeeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmployeeStatus'>
    


/**
 * Reference to a field of type 'EmployeeStatus[]'
 */
export type ListEnumEmployeeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmployeeStatus[]'>
    


/**
 * Reference to a field of type 'ContractType'
 */
export type EnumContractTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContractType'>
    


/**
 * Reference to a field of type 'ContractType[]'
 */
export type ListEnumContractTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContractType[]'>
    


/**
 * Reference to a field of type 'WorkRegime'
 */
export type EnumWorkRegimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkRegime'>
    


/**
 * Reference to a field of type 'WorkRegime[]'
 */
export type ListEnumWorkRegimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkRegime[]'>
    


/**
 * Reference to a field of type 'TimeEntryType'
 */
export type EnumTimeEntryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TimeEntryType'>
    


/**
 * Reference to a field of type 'TimeEntryType[]'
 */
export type ListEnumTimeEntryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TimeEntryType[]'>
    


/**
 * Reference to a field of type 'AbsenceType'
 */
export type EnumAbsenceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AbsenceType'>
    


/**
 * Reference to a field of type 'AbsenceType[]'
 */
export type ListEnumAbsenceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AbsenceType[]'>
    


/**
 * Reference to a field of type 'AbsenceStatus'
 */
export type EnumAbsenceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AbsenceStatus'>
    


/**
 * Reference to a field of type 'AbsenceStatus[]'
 */
export type ListEnumAbsenceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AbsenceStatus[]'>
    


/**
 * Reference to a field of type 'PayrollStatus'
 */
export type EnumPayrollStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayrollStatus'>
    


/**
 * Reference to a field of type 'PayrollStatus[]'
 */
export type ListEnumPayrollStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayrollStatus[]'>
    


/**
 * Reference to a field of type 'PayrollItemType'
 */
export type EnumPayrollItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayrollItemType'>
    


/**
 * Reference to a field of type 'PayrollItemType[]'
 */
export type ListEnumPayrollItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayrollItemType[]'>
    


/**
 * Reference to a field of type 'CompanyStatusEnum'
 */
export type EnumCompanyStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyStatusEnum'>
    


/**
 * Reference to a field of type 'CompanyStatusEnum[]'
 */
export type ListEnumCompanyStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyStatusEnum[]'>
    


/**
 * Reference to a field of type 'Bytes'
 */
export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


/**
 * Reference to a field of type 'Bytes[]'
 */
export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


/**
 * Reference to a field of type 'TenantStatusEnum'
 */
export type EnumTenantStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantStatusEnum'>
    


/**
 * Reference to a field of type 'TenantStatusEnum[]'
 */
export type ListEnumTenantStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantStatusEnum[]'>
    


/**
 * Reference to a field of type 'PlanTierEnum'
 */
export type EnumPlanTierEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlanTierEnum'>
    


/**
 * Reference to a field of type 'PlanTierEnum[]'
 */
export type ListEnumPlanTierEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlanTierEnum[]'>
    


/**
 * Reference to a field of type 'SystemModuleEnum'
 */
export type EnumSystemModuleEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SystemModuleEnum'>
    


/**
 * Reference to a field of type 'SystemModuleEnum[]'
 */
export type ListEnumSystemModuleEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SystemModuleEnum[]'>
    


/**
 * Reference to a field of type 'BankAccountType'
 */
export type EnumBankAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BankAccountType'>
    


/**
 * Reference to a field of type 'BankAccountType[]'
 */
export type ListEnumBankAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BankAccountType[]'>
    


/**
 * Reference to a field of type 'BankAccountStatus'
 */
export type EnumBankAccountStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BankAccountStatus'>
    


/**
 * Reference to a field of type 'BankAccountStatus[]'
 */
export type ListEnumBankAccountStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BankAccountStatus[]'>
    


/**
 * Reference to a field of type 'FinanceCategoryType'
 */
export type EnumFinanceCategoryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FinanceCategoryType'>
    


/**
 * Reference to a field of type 'FinanceCategoryType[]'
 */
export type ListEnumFinanceCategoryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FinanceCategoryType[]'>
    


/**
 * Reference to a field of type 'FinanceEntryType'
 */
export type EnumFinanceEntryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FinanceEntryType'>
    


/**
 * Reference to a field of type 'FinanceEntryType[]'
 */
export type ListEnumFinanceEntryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FinanceEntryType[]'>
    


/**
 * Reference to a field of type 'FinanceEntryStatus'
 */
export type EnumFinanceEntryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FinanceEntryStatus'>
    


/**
 * Reference to a field of type 'FinanceEntryStatus[]'
 */
export type ListEnumFinanceEntryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FinanceEntryStatus[]'>
    


/**
 * Reference to a field of type 'FinanceEntryRecurrence'
 */
export type EnumFinanceEntryRecurrenceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FinanceEntryRecurrence'>
    


/**
 * Reference to a field of type 'FinanceEntryRecurrence[]'
 */
export type ListEnumFinanceEntryRecurrenceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FinanceEntryRecurrence[]'>
    


/**
 * Reference to a field of type 'RecurrenceUnit'
 */
export type EnumRecurrenceUnitFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecurrenceUnit'>
    


/**
 * Reference to a field of type 'RecurrenceUnit[]'
 */
export type ListEnumRecurrenceUnitFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecurrenceUnit[]'>
    


/**
 * Reference to a field of type 'FinanceAttachmentType'
 */
export type EnumFinanceAttachmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FinanceAttachmentType'>
    


/**
 * Reference to a field of type 'FinanceAttachmentType[]'
 */
export type ListEnumFinanceAttachmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FinanceAttachmentType[]'>
    


/**
 * Reference to a field of type 'LoanType'
 */
export type EnumLoanTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LoanType'>
    


/**
 * Reference to a field of type 'LoanType[]'
 */
export type ListEnumLoanTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LoanType[]'>
    


/**
 * Reference to a field of type 'LoanStatus'
 */
export type EnumLoanStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LoanStatus'>
    


/**
 * Reference to a field of type 'LoanStatus[]'
 */
export type ListEnumLoanStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LoanStatus[]'>
    


/**
 * Reference to a field of type 'ConsortiumStatus'
 */
export type EnumConsortiumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConsortiumStatus'>
    


/**
 * Reference to a field of type 'ConsortiumStatus[]'
 */
export type ListEnumConsortiumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConsortiumStatus[]'>
    

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export type PrismaClientOptions = ({
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.
   */
  adapter: runtime.SqlDriverAdapterFactory
  accelerateUrl?: never
} | {
  /**
   * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
   */
  accelerateUrl: string
  adapter?: never
}) & {
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   * 
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * 
   * ```
   * Read more in our [docs](https://pris.ly/d/logging).
   */
  log?: (LogLevel | LogDefinition)[]
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: TransactionIsolationLevel
  }
  /**
   * Global configuration for omitting model fields by default.
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig
  /**
   * SQL commenter plugins that add metadata to SQL queries as comments.
   * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   adapter,
   *   comments: [
   *     traceContext(),
   *     queryInsights(),
   *   ],
   * })
   * ```
   */
  comments?: runtime.SqlCommenterPlugin[]
}
export type GlobalOmitConfig = {
  user?: Prisma.UserOmit
  userProfile?: Prisma.UserProfileOmit
  session?: Prisma.SessionOmit
  refreshToken?: Prisma.RefreshTokenOmit
  permission?: Prisma.PermissionOmit
  permissionGroup?: Prisma.PermissionGroupOmit
  permissionGroupPermission?: Prisma.PermissionGroupPermissionOmit
  userPermissionGroup?: Prisma.UserPermissionGroupOmit
  userDirectPermission?: Prisma.UserDirectPermissionOmit
  permissionAuditLog?: Prisma.PermissionAuditLogOmit
  organization?: Prisma.OrganizationOmit
  organizationAddress?: Prisma.OrganizationAddressOmit
  organizationCnae?: Prisma.OrganizationCnaeOmit
  organizationFiscalSettings?: Prisma.OrganizationFiscalSettingsOmit
  organizationStakeholder?: Prisma.OrganizationStakeholderOmit
  supplier?: Prisma.SupplierOmit
  manufacturer?: Prisma.ManufacturerOmit
  category?: Prisma.CategoryOmit
  warehouse?: Prisma.WarehouseOmit
  zone?: Prisma.ZoneOmit
  bin?: Prisma.BinOmit
  volume?: Prisma.VolumeOmit
  volumeItem?: Prisma.VolumeItemOmit
  template?: Prisma.TemplateOmit
  product?: Prisma.ProductOmit
  variant?: Prisma.VariantOmit
  item?: Prisma.ItemOmit
  itemMovement?: Prisma.ItemMovementOmit
  productCategory?: Prisma.ProductCategoryOmit
  variantPriceHistory?: Prisma.VariantPriceHistoryOmit
  auditLog?: Prisma.AuditLogOmit
  tag?: Prisma.TagOmit
  productTag?: Prisma.ProductTagOmit
  variantImage?: Prisma.VariantImageOmit
  alert?: Prisma.AlertOmit
  purchaseOrder?: Prisma.PurchaseOrderOmit
  purchaseOrderItem?: Prisma.PurchaseOrderItemOmit
  unitConversion?: Prisma.UnitConversionOmit
  stockSnapshot?: Prisma.StockSnapshotOmit
  customer?: Prisma.CustomerOmit
  salesOrder?: Prisma.SalesOrderOmit
  salesOrderItem?: Prisma.SalesOrderItemOmit
  itemReservation?: Prisma.ItemReservationOmit
  variantSupplierCode?: Prisma.VariantSupplierCodeOmit
  variantPromotion?: Prisma.VariantPromotionOmit
  comment?: Prisma.CommentOmit
  notificationPreference?: Prisma.NotificationPreferenceOmit
  notificationTemplate?: Prisma.NotificationTemplateOmit
  notification?: Prisma.NotificationOmit
  request?: Prisma.RequestOmit
  requestAttachment?: Prisma.RequestAttachmentOmit
  requestComment?: Prisma.RequestCommentOmit
  requestHistory?: Prisma.RequestHistoryOmit
  employee?: Prisma.EmployeeOmit
  department?: Prisma.DepartmentOmit
  position?: Prisma.PositionOmit
  timeEntry?: Prisma.TimeEntryOmit
  workSchedule?: Prisma.WorkScheduleOmit
  overtime?: Prisma.OvertimeOmit
  timeBank?: Prisma.TimeBankOmit
  absence?: Prisma.AbsenceOmit
  vacationPeriod?: Prisma.VacationPeriodOmit
  payroll?: Prisma.PayrollOmit
  payrollItem?: Prisma.PayrollItemOmit
  bonus?: Prisma.BonusOmit
  deduction?: Prisma.DeductionOmit
  company?: Prisma.CompanyOmit
  companyAddress?: Prisma.CompanyAddressOmit
  companyCnae?: Prisma.CompanyCnaeOmit
  companyFiscalSettings?: Prisma.CompanyFiscalSettingsOmit
  companyStakeholder?: Prisma.CompanyStakeholderOmit
  labelTemplate?: Prisma.LabelTemplateOmit
  tenant?: Prisma.TenantOmit
  plan?: Prisma.PlanOmit
  planModule?: Prisma.PlanModuleOmit
  tenantPlan?: Prisma.TenantPlanOmit
  tenantUser?: Prisma.TenantUserOmit
  tenantFeatureFlag?: Prisma.TenantFeatureFlagOmit
  costCenter?: Prisma.CostCenterOmit
  bankAccount?: Prisma.BankAccountOmit
  financeCategory?: Prisma.FinanceCategoryOmit
  financeEntry?: Prisma.FinanceEntryOmit
  financeEntryPayment?: Prisma.FinanceEntryPaymentOmit
  financeAttachment?: Prisma.FinanceAttachmentOmit
  loan?: Prisma.LoanOmit
  loanInstallment?: Prisma.LoanInstallmentOmit
  consortium?: Prisma.ConsortiumOmit
  consortiumPayment?: Prisma.ConsortiumPaymentOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
  ? GetLogType<T[number]>
  : never;

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw'
  | 'groupBy'

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>

